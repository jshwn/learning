# System Design
IT 서비스는 항상 운영, 예측 가능성, 확장 가능성 염두하고 설계해야 한다.

시스템은 Entity, State, Action(또는 Operation)으로 구성된다.

* 시스템 디자인 설계 목표
  * 운영: 운영이 편해야 한다.
  * 예측 가능성
    * 다양한 의미로 해석 가능한데, 여기서는 **"비즈니스 수준에서"** 시스템이 예측한 대로 동작하여 오류가 없는 것을 말한다.
    * 즉, 시스템에 정의된 Action들은 모두 닫혀 있어야 한다(closed)
  * 통계: 운영과 비슷한 맥락인데, 통계 자료를 산출하기 편해야 한다.

##  설계 구상
### Entity
* 구조
  * 종류: tree 관계(Composition), 집합 관계, 순서 관계, 연관 관계
  * type (엔티티 분류)

### State
* 연산

### Action
* 하나의 비즈니스 로직(예: 결재 승인, 회원 탈퇴 등)에 대하여 생각해볼 수 있는 지점
  * bulk action (집단 실행)
    * 관리자가 어떠한 사유로 수십 명의 회원을 탈퇴시키는 경우, 단체로 회원을 탈퇴시킬 수 있는 기능이 없다면 일일이 회원탈퇴 버튼을 눌러야 할 것이다.
    * 따라서 복수의 비즈니스 로직 실행을 한 번에 할 수 있어야 한다.
  * concurrent action (동시 실행)
    * 물리적으로 동시 실행이 아니라 비즈니스 수준에서 동시로 기록할 필요가 있는 경우
    * 예를 들어 두 행의 정보를 서로 교차 변경시키는 경우, UPDATE를 각각에 대하여 2번 해야 하지만 변경 시점이 같도록 할 필요가 있으면 동시 실행으로 처리할 필요가 있다.
    * 대표적인 예시가 바로 **연초의 대규모 조직 개편과 인사 발령**이다.
  * idempotent action (멱등 실행)
    * 연산을 여러번 실행해도 상태가 같은 것
    * 참고: https://developer.mozilla.org/ko/docs/Glossary/Idempotent
  * invertible action (역 실행)
    * 임의의 action a의 실행으로 변경된 entity의 status를 a 실행 이전으로 돌리는 것
    * a(s) = a * s = s'이라면, invertible action은 a^(-1)(s') = s' * a^(-1) = s
    * invertible action이 로그까지 날리는지는 정하기에 따라 다르다(git log를 생각하면 쉽다).
      * 최악의 경우에는 상태 변경 순서까지 revert 또는 수정해야 할 수 있다.
      * 예를 들어 결재 순서가 모종의 이유로 잘못된 경우, 그리고 다른 시스템이 그 결재 순서에 의존하고 있는 경우에는 결재 순서를 수정하여 의존 시스템에 동기화시켜야 할 필요가 있을 수 있다.
      * 이런 경우에는 상태 자체를 entity화 시킬 필요가 있으며, 수정해서 
    * **결론**
      * 비즈니스 로직에서 상태의 순서가 중요할 경우에는, 상태들의 순서 구조 그 자체를 연산의 대상으로 할 필요가 있다.
      * 비정상적인 데이터 비일관성 이슈에 대비하여 

##  백오피스 시스템 공통 도메인
* 유저
  * 가입(생성), 탈퇴(삭제 or soft delete)
* 조직
  * 놀랍게도, 필요에 따라 포함관계뿐만 아니라 연관관계도 가능해야 한다.
  * 결국 하나의 표에 띄우려면, 같은 entity여야 한다. (아니면 union해야 하니까)
  * 연관 관계인 조직이 있는 경우에도 비정규화를 할 수 있는지는 의문
* 역할 vs 권한 (or both)
* 결재
* 결재와 권한의 경우, 보통 조직 안에서만 가능해야 하지만 **협업**하는 경우에는 서로의 데이터를 확인하기 위해서는 결재자 지정 대상이나 권한을 공유할 필요가 있다.
  * 이 경우에는 프로젝트, task force 등의 일종의 연관관계 조직을 만들어서 매핑할 수 있을 것이다.
  * **아예 복수의 조직 자체가 하나로 합쳐지거나, 갈라지는 것도 생각해볼 수 있다.**