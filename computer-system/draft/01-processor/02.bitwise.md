(임시)

개수, 위치, 내용(값) 모두 자연수로 표현 가능하다.
*  명수법: 개수, 내용(단위의 값)
*  위치값: 내용, 위치

이렇게 대응된다.

#   Bitwise Operations

##  기수법 Numeral system
기수법이란, 명칭 그대로 수를 표기하는 방법이다.

기수법은 단항기수법, 명수법, 위치값 기수법으로 구분할 수 있다.

단항기수법(또는 일진법)이란, 수를 나타내는 기호가 1개인 기수법이다.
예를 들어 단위 기호가 $\text{I}$인 경우, $\text{IIIII}$은 자연수 5를 의미한다.
이때 기호의 개수가 곧 해당 수의 크기를 의미한다.

명수법은 명칭 그대로 수에 이름을 붙인다는 뜻으로, 특정 수치에 특정 기호를 대응시키는 것을 의미한다.
단항기수법은 자연수 1에만 기호 $\text{I}$를 대응시켰다고 볼 수 있으며, 명수법은 여러 수치에 기호를 대응시킨다고 볼 수 있다.

명수법의 가장 대표적인 예시로 로마 숫자(또는 로마 기수법, roman numerals)가 있다.
로마 기수법에서는 자연수 1을 $\text{I}$로, 자연수 10를 $\text{X}$로, 자연수 100을 $\text{M}$으로 표기한다.
예를 들어 자연수 321의 로마 숫자는 $\text{CCCXXI}$이다.

로마 기수법은 수를 표현하는 기호의 개수를 줄이기 위해 특수한 규칙을 사용하며, 이때 기호들의 순서가 매우 중요하다.
예를 들어 44를 로마 기수법으로 표기하면 $\text{XLIV}$이다.
이는 $\text{XXXXIIII}$를 축약하기 위함이다.
이때 $\text{XLIV}$의 문자들 중 어느 것이라도 순서가 바뀌면 그 값도 바뀌게 된다.

**하지만 이 글에서는 논의의 편의를 위해 명수법이 기호들의 위치 순서를 고려하지 않는다고 가정한다.**
즉, $\text{CCCXXI}$나 $\text{CXCIXC}$도 모두 321의 값으로 해석한다.

따라서 만약 기호들의 순서가 표기 규칙과 무관하다면, 기호들의 개수에 수치를 곱한 값들의 합이 수치값을 의미한다.

**여기서 중요한 점은 단항기수법이든 (위의 가정을 따르는) 명수법이든 어떤 기호에 대하여 그 기호의 개수가 수치의 크기와 선형적으로 대응한다는 사실이다.**

### 위치값 기수법 Positional notation
현대 아라비아 숫자 체계의 기수법은 위치값 기수법을 전제한다.

위치값 기수법은 숫자 기호의 위치들에 계수(coefficient)를 부여한다.
그리고 숫자열의 수치값은 해당 위치의 숫자 기호의 수치만큼 그 위치의 계수를 합한 값이다.

예를 들어 10진법 숫자열 "321"의 경우, 숫자 기호 3의 계수는 100, 2의 계수는 10, 1의 계수는 1이다.

자연수 321의 로마 숫자가 "CCCXXI"인 것을 감안하면, 10진법에서 숫자의 위치는 단위 기호의 크기를, 해당 위치에 있는 숫자의 크기는 해당 단위 기호의 개수를 의미한다고 볼 수 있다.
이때 10진법에서의 계수들은 10의 양의 정수만큼 거듭제곱한 값들만 가능하다.

일반적으로 수열이나 문자열의 원소들의 순서를 나타낼 때 첨수를 사용할 경우, 자연수 1부터 해당 수열이나 문자열의 길이 $n$까지 부여한다.
예를 들어 $\psi_1, \psi_2, \cdots, \psi_n$ 이런 식이다.

하지만 위치값 기수법에서는 숫자열의 길이 $w$에 대하여 원소의 첨수를 다음과 같이 정의할 수 있다.
(원래 $w$는 포인터의 단위인 word의 두문자이지만 이 단락에서는 width라고 여겨도 무방하다.)

$$
\psi_{w-1}\psi_{w-2} \cdots \psi_{1}\psi_{0}
$$

첨수의 순서가 rtl(right to left)인 이유는 자릿수 확장이 오른쪽에서 왼쪽으로 이루어지는 아라비아 표기법을 그대로 따르는 것이다.

첨수의 순서가 rtl이냐 ltr이냐의 문제는 표기법의 문제에 불과하다. 예를 들어 십진수 위치 표기법 숫자열 $321$을 ltr(left to right)으로 표기하면 $123$이 된다. 하지만 인코딩이 다를 뿐, 두 숫자열 모두 자연수 123을 의미한다. 따라서 수학적으로 접근할 때 첨수의 표기 순서는 그렇게 중요하지 않다.

그리고 첨수의 값은 해당 원소의 계수를 암시한다.
각 위치의 첨수값에 대하여 기수(radix)를 그 첨수값만큼 제곱하면 계수(coefficient)가 나오기 때문이다.

다음은 기수가 $r$이고 길이가 $w$인 위치값 기수법 숫자열 $\psi^{r}$의 수치를 계산하는 함수의 공식이다.
이때 $\psi_{i}$는 $i$ 위치의 숫자 기호의 값을 의미한다.

$$
\tau \left( \psi^{r} \right) = \sum\limits_{i=0}^{w-1} { \psi_{i} \cdot r^{i}}
$$

    (그림 필요)


이때 이진수를 형식적인 관점에서 숫자열 대신 비트열(bit sequence)이라고 부를 수 있다.

##  비트 벡터
숫자열의 숫자로 구성된 행벡터로 표현할 수 있으며, 마찬가지로 비트열도 비트 벡터로 표현할 수 있다. 단, 이때 숫자나 비트(0,1)는 모두 숫자가 아니라 수로 취급한다.

$$
\vec{x} = [x_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ w \  \}} \; = [ x_{w-1}, ..., x_0 ] \; \left(  \forall x_i \in \{ x_i \in \mathbb{Z^+} \ | \ x_i < r \} \right)
$$

이때 1바이트 비트 벡터의 $w$ 값은 8이며 이는 다음과 같이 정의할 수 있다.
$$
\vec{b} = [b_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ 8 \  \}} \; = [ b_{7}, ..., b_0 ] \; \left(  \forall b_i \in \{ 0, 1 \} \right)
$$

###   비트 벡터와 유한집합 인코딩
비트 벡터에 대하여 $i$번째 원소 $b_i$ 를 $i$번째 비트라고 한다.

그리고 $b$의 너비(또는 길이) $b$에 대하여 $b_0$를 최하위 비트(LSB, Least Significant Bit), $b_{w-1}$를 최상위 비트(MSB, Most Significant Bit)라고 한다.



비트 벡터를 사용하여 유한집합을 인코딩할 수도 있다.

예를 들어 비트 벡터가 $[0,1,1,0,1,0,0,1]$이라면, 이는 양의 정수에 대한 임의의 유한집합 $A= \left\{ 0, 3, 5, 6 \right\}$를 인코딩한다.

즉, 유한집합 인코딩에서는 비트 벡터의 위치값이 양의 정수 유한집합의 원소를 의미한다.

##  Boolean Algebra
difference with Boolean Ring

Boolean Algebra의 연산을 정의하는 방법에는 조각적 정의 함수(piecewise-defined function)로 정의하는 방법과 Tarski(1953)의 방법이 있다.

Tarski의 정의는 해석적이지만 진리값이 자연수가 아니면 사용할 수 없다. 반면 조각적 정의 함수를 이용한 정의는 진리값이 자연수가 아니어도 사용할 수 있다.

###   Operation defitions with piecewise-defined function

*
   $$
   a \wedge b = \begin{cases}
      1 &\text{if } a=b=1 \\
      0 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \vee b = \begin{cases}
      0 &\text{if } a=b=0 \; \\
      1 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \veebar b = \begin{cases}
      0 &\text{if } a=b \quad \quad \\
      1 &\text{else}
   \end{cases} 
   $$
*  
   $$
   \neg \ a = \begin{cases}
      0 &\text{if } a=1 \quad \;\ \\
      1 &\text{else}
   \end{cases} 
   $$

###   Operation Definitions of Tarski
*   $a \wedge b =\text{min}(a,b) \;  \text{or} \; a \times b $
*   $a \vee b = \text{max}(a,b) \; \text{or} \; a+b - a \times b $
*   $ a \veebar b = (a-b)^2$
*   $ \neg \; a \;\ = 1-a$

참고로 $a+b$ 식만으로는 비트 연산을 정의할 수 없다. $a=1, \; b=1$일 때 $a+b$는 수의 범위를 벗어나기 때문이다.
$a-b$ 식도 a=0, b=1일 때 값이 -1이 되므로 이 역시 단일로 정의될 수 없다.

+  그 외 연산의 성질, 드모르간 법칙

##  시프트 연산
비트 벡터에 대한 시프트 연산을 수학적으로 정의하는 것은 우아하지 못하다.

*   logical left shit
*   logical right shift
*   arithmetic right shit

##  추가: 비트마스크