(임시)

#   수치 데이터의 표현과 조작
이 글에서는 수를 "숫자열"과 그 "수치 또는 수학적 의미"로 구분한다.
형식논리학의 맥락에 비추어 본다면 이는 각각 형식적 관점과 의미론적 관점을 전제한다고 볼 수 있다.

예를 들어 임의의 수 "1234"에 대하여 형식적인 관점에서는 "1,2,3,4번째 자리에 기호 1,2,3,4가 배치된 숫자 기호들의 열(이하 '숫자열')"로 취급할 수 있고, 이를 의미론적 관점에서는 "자연수 1234"로 취급할 수 있다.

여기서 "1234"를 10진수가 아니라 16진수로 해석한다면, 그 수학적 의미는 "자연수 1234"가 아니라 "자연수 4660"이 될 것이다.

##  기수법 Numeral system
기수법이란, 명칭 그대로 수를 표기하는 방법이다.

기수법은 단항기수법, 명수법, 위치값 기수법으로 구분할 수 있다.

단항기수법(또는 일진법)이란, 수를 나타내는 기호가 1개인 기수법이다.
예를 들어 단위 기호가 1인 경우, 11111은 자연수 $5$를 의미한다.
이때 기호의 개수가 곧 해당 수의 크기를 의미한다.

명수법은 명칭 그대로 수에 이름을 붙인다는 뜻으로, 특정 수치에 특정 기호를 대응시키는 것을 의미한다.
단항기수법은 자연수 1에만 기호를 대응시켰다고 볼 수 있으며, 명수법은 여러 수치에 기호를 대응시킨다고 볼 수 있다.

명수법의 가장 대표적인 예시로 로마 숫자(또는 로마 기수법, roman numerals)가 있다.
로마 기수법에서는 자연수 1을 $\textrm{I}$로, 자연수 10를 $\textrm{X}$로, 자연수 100을 $\textrm{M}$으로 표기한다.
예를 들어 자연수 321의 로마 숫자는 $\textrm{CCCXXI}$이다.

로마 기수법은 수를 표현하는 기호의 개수를 줄이기 위해 특수한 규칙을 사용하며, 이때 기호들의 순서가 매우 중요하다.
예를 들어 44를 로마 기수법으로 표기하면 $\textrm{XLIV}$이다.
이는 $\textrm{XXXXIIII}$를 축약하기 위함이다.
이때 $\textrm{XLIV}$의 문자들 중 어느 것이라도 순서가 바뀌면 그 값도 바뀌게 된다.

**하지만 이 글에서는 논의의 편의를 위해 명수법이 기호들의 위치 순서를 고려하지 않는다고 가정한다.**

만약 기호들의 순서가 표기 규칙과 무관하다면, 기호들의 개수에 수치를 곱한 값들의 합이 수치값을 의미한다.

**여기서 중요한 점은 단항기수법이든 명수법이든 어떤 기호에 대하여 그 기호의 개수가 수치의 크기와 선형적으로 대응한다는 사실이다.**

### 위치값 기수법 Positional notation
현대 아라비아 숫자 체계의 기수법은 위치값 기수법을 전제한다.

위치값 기수법은 숫자 기호의 위치들에 계수(coefficient)를 부여한다.
그리고 숫자열의 수치값은 해당 위치의 숫자 기호의 수치만큼 그 위치의 계수를 합한 값이다.

예를 들어 10진법 숫자열 "321"의 경우, 숫자 기호 3의 계수는 100, 2의 계수는 10, 1의 계수는 1이다.

자연수 321의 로마 숫자가 "CCCXXI"인 것을 감안하면, 10진법에서 숫자의 위치는 단위 기호의 크기를, 해당 위치에 있는 숫자의 크기는 해당 단위 기호의 개수를 의미한다고 볼 수 있다.
다만 이때 계수들은 10의 양의 정수만큼 거듭제곱한 값들만 가능하다.

일반적으로 수열이나 문자열의 원소들의 순서를 나타낼 때 첨수를 사용할 경우, 자연수 1부터 해당 수열이나 문자열의 길이 $n$까지 부여한다.
예를 들어 $x_1, x_2, \cdots, x_n$ 이런 식이다.

하지만 위치값 기수법에서는 숫자열의 길이 $w$에 대하여 원소의 첨수를 다음과 같이 정의할 수 있다.
(원래 $w$는 포인터의 단위인 word의 두문자이지만 이 단락에서는 width라고 여겨도 무방하다.)

$$
x_{w-1}x_{w-2} \cdots x_{1}x_{0}
$$

첨수의 순서가 이와 같은 것은 자릿수 확장이 오른쪽에서 왼쪽으로 이루어지는 아라비아 표기법을 그대로 따르는 것이다.
동시에 첨수의 값은 해당 원소의 계수를 암시한다.
각 위치의 첨수의 값에 대하여 기수(radix)를 그 첨수값만큼 제곱하면 계수(coefficient)가 나오기 때문이다.

다음은 기수가 $r$이고 길이가 $w$인 위치값 기수법 숫자열 $x_{r}$의 수치를 계산하는 함수의 공식이다.
이때 $x_{i}$는 $i$ 위치의 숫자 기호의 값을 의미한다.

$$
f \left( x_{r} \right) = \sum\limits_{i=0}^{w-1} { x_{i} \cdot r^{i}}
$$

    (그림 필요)



이때 이진수를 형식적인 관점에서 숫자열 대신 비트열(bit sequence)이라고 부를 수 있다.

##  비트 벡터
숫자열은 숫자로 구성된 행벡터로 표현할 수 있으며, 마찬가지로 비트열도 비트 벡터로 표현할 수 있다.

$$
\vec{x} = [x_i] \; \left( \rm{for} \; i = w-1, \; ... \; 0, \; w > 0 \right) = [ x_{w-1}, ..., x_0 ]
$$

비트 벡터를 사용하여 유한집합을 인코딩할 수도 있다.

예를 들어 비트 벡터가 $[01101001]$이라면, 이는 양의 정수에 대한 임의의 유한집합 $A= \left\{ 0, 3, 5, 6 \right\}$를 인코딩한다.

즉, 유한집합 인코딩에서는 비트 벡터의 위치값이 양의 정수 유한집합의 원소를 의미한다.

##  정수 인코딩

### 부호 없는 정수  Unsigned Integer
크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$에 대하여 부호 없는 정수 인코딩에서 가지는 값은 다음과 같이 계산할 수 있다.

$$
B2U_{w} \left( \vec{x} \right) \doteq \sum\limits_{i=0}^{w-1} { x_{i} \cdot 2^{i}}
$$

이는 위치기수법에서 숫자열의 수치값을 구하는 공식과 같다.

| $x_w$| $n$ |
| :-:  | :-: |
| 1111 | 15  |
| $\cdots$ | $\cdots$ |
| 0100 |  4  |
| 0011 |  3  |
| 0010 |  2  |
| 0001 |  1  |
| 0000 |  0  |


### 부호 있는 정수  Signed Integer
일반적으로 십진수 음수를 표기할 때 우리는 숫자열 좌측에 $-$ 기호를 붙인다.
음의 이진수 역시 숫자열 좌측에 $-$ 기호를 붙이는 방법으로 표기할 수 있지만, 메모리에 음수를 저장할 때는 0과 1을 제외한 다른 값을 사용할 수가 없다.

0과 1만으로 양의 정수와 음의 정수를 모두 표현하기 위한 인코딩 방법을 **부호 있는 정수(Signed Integer)**라고 한다. 부호 있는 정수 인코딩에는 **부호 절대값(Signed Magnitude)**, **1의 보수(One's Complement)** 그리고 **2의 보수(Two's Complement)**가 있다.

### 부호 절대값     Signed Magnitude
부호 절대값 인코딩은 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 지정하고 나머지 비트는 부호 없는 정수와 동일한 인코딩을 적용한다.

이는 사람 입장에서 비트열을 보고 해당 비트열의 정수 값을 직관적으로 계산할 수 있다는 장점이 있다.
하지만 기계 입장에서는 정수의 부호를 전환하거나 뺄셈 연산을 할 때 상대적으로 많은 비용이 발생한다는 단점이 있다.
또한 1의 보수와 마찬가지로 0의 값이 2개이므로 표현할 수 있는 정수의 범위가 2의 보수보다 1단위 적다.

크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$의 부호 절대값 인코딩의 정수값은 다음과 같이 계산한다.

$$
B2S_{w} \left( \vec{x} \right) \doteq \left( - 1 \right)^{ x_{w-1} } \cdot \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

| $x_w$| $n$ |
| :-:  | :-: |
| 0111 |  7  |
| $\cdots$ | $\cdots$ |
| 0011 |  3  |
| 0010 |  2  |
| 0001 |  1  |
| 0000 |  0  |
| 1000 | -0  |
| 1001 | -1  |
| 1010 | -2  |
| 1011 | -3  |
| $\cdots$ | $\cdots$ |
| 1111 | -7  |


### 1의 보수       One's Complement

    (주판과 보수)

1의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  더한 값에 캐리 비트의 값을 더한다.

$$
B2O_{w} \left( \vec{x} \right) \doteq -x_{w-1} \left( 2^{w-1} - 1 \right) + \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

| $x_w$| $n$ |
| :-:  | :-: |
| 0111 |  7  |
| $\cdots$ | $\cdots$ |
| 0011 |  3  |
| 0010 |  2  |
| 0001 |  1  |
| 0000 |  0  |
| 1111 | -0  |
| 1110 | -1  |
| 1101 | -2  |
| 1100 | -3  |
| $\cdots$ | $\cdots$ |
| 1000 | -7  |

1의 보수와 2의 보수 모두 어떤 비트 벡터를 가지는 정수에 대하여 그 덧셈의 역원과 덧셈 연산을 수행할 때 그 결과값이 항상 0이 나와야 한다.

1의 보수 인코딩은 임의의 정수와 그 역원의 합이 -0의 비트값을 가지는 반면, 2의 보수법은 0의 값을 가지는 비트 벡터가 하나이므로 그 역원과의 합이 0의 비트값을 가진다.

1의 보수 인코딩의 경우, 부호 반전이 매우 간단하다. 부호 반전이 곧 비트 반전이기 때문이다.
하지만 2의 보수와 비교할 때 비용이 더 많이 들 수 있으며, 부호 절대값 인코딩처럼 정수의 표현 범위가 2의 보수 인코딩보다 1단위 더 작다.

### 2의 보수       Two's Complement

크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$ 에 대하여 그 비트 벡터의 부호 없는 정수값 $x$을 $2^w$에서 뺀 값 $2^w - x$이 있다고 하자.
이때 $2^w - x$을 부호 없는 정수 인코딩으로 매핑한 비트 벡터가 2의 보수 인코딩에서 정수 $x$의 덧셈에 대한 역원 $-x$의 비트 벡터와 같다. (이때 $\textrm{TMIN}_w$은 역원을 가지지 않으므로 예외이다)

"2의 보수 인코딩"이라는 명칭에서 "2의 보수"라는 표현은 위의 맥락을 반영한다.

2의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  캐리 값은 버린다.

따라서 뺄셈 연산이 1의 보수 인코딩보다 더 간단하다.
또한  2의 보수 인코딩은 다른 부호 있는 정수 인코딩과 달리 정수 0에 매핑되는 비트 벡터가 하나이므로 표현 범위가 부호 최대치 및 1의 보수 인코딩보다 1단위 더 크다.
대신 부호 전환이 1의 보수보다 비교적 번거롭다.

하지만 2의 보수 인코딩의 장점이 다른 부호 있는 인코딩을 압도하므로, 모든 시스템에서 정수의 비트 표현 방법으로 2의 보수 인코딩을 채택한다고 여겨도 무방하다.

$$
B2T_{w} \left( \vec{x} \right) \doteq -x_{w-1} \cdot 2^{w-1} +  \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

| $x_w$| $n$ |
| :-:  | :-: |
| 0111 |  7  |
| $\cdots$ | $\cdots$ |
| 0011 |  3  |
| 0010 |  2  |
| 0001 |  1  |
| 0000 |  0  |
| 1111 | -1  |
| 1110 | -2  |
| 1101 | -3  |
| $\cdots$ | $\cdots$ |
| 1001 | -7  |
| 1000 | -8  |

##  부호 있는 정수와 부호 없는 정수 간의 변환
C언어에서는 다음과 같이 타입 캐스팅(명시적 또는 강제적 형변환)을 통해 부호 정수형과 비부호 정수형를 서로 변환할 수 있다.

```cpp
int main(){
    unsigned int i = 4294967295U;
    /* UINT_MAX in limits.h, 32bit 머신 기준 */
    printf("UINT_MAX = %d\n", (int) i);  /* -1 */
    return 0;
}
```


$$
\textrm{TMin}_{w} \leq x \leq \textrm{TMax}_w, \\
T2U_w \left( x \right) =
\begin{cases}
   x+2^w, & x < 0 \\
   x, & x \geq 0
\end{cases}
$$


$$
B2U_w \left( T2B_w \left( x \right) \right) = T2U_w \left( x \right) = x + x_{w-1} \cdot 2^w
$$


##  정수의 비트 확장(Extension)
0의 확장과 부호 확장

##  정수의 비트 절삭(Truncate)
모듈러 연산이 등장하는 첫번째 연산

##  정수의 산술 연산

### 정수의 덧셈

### 정수의 곱셈

### 정수의 나눗셈

##  실수의 인코딩 (IEE 754)

##  임의 정밀도 산술 Arbitrary Precision Arithmetic