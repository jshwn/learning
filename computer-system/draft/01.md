#   Data Types and Operations
자료형과 연산

##  Introduction
이 글에서는 자료형으로 정수와 부동소수점수만 전제한다.
프로세서에서 하드웨어 수준으로 지원하는 자료형이 정수와 부동소수점수 둘뿐이기 때문이다.
그리고 프로세서에서 하드웨어 수준으로 지원하기에, 정수와 부동소수점수의 값은 특정 비트열의 값에 대응한다.

이 글에서 정수(integer)라는 용어를 사용할 때 전산학에서의 정수와 수학에서의 정수 개념을 혼용한다. 연산의 경우에도 수학에서의 연산과 컴퓨터에서의 연산 개념을 혼용한다.

대수 구조는 집합과 연산으로 정의된다.
그리고 연산은 자료형에 대해 정의된다.

---

하지만 정수와 부동소수점수는 각각 상한과 하한을 가지기 때문에, 연산 결과가 표현 범위를 넘어설 수 있다.
연산 결과가 정수의 최댓값을 넘어서면 오버플로우(overflow), 최솟값을 넘어서면 언더플로우(underflow)라고 한다.
보통 이런 문제를 지칭할 때 오버플로우라는 용어로 통일하며, 각 자료형에 대해서는 정수 오버플로우와 부동소수점수 오버플로우라고 부른다.

연산 결과의 오버플로우는 컴파일 타임 컴파일러가 탐지할 수도 있고 런타임에 프로세서나 기타 하드웨어가 탐지할 수 있다.
우리가 생각해볼 수 있는 프로세서 구현에서는 오버플로우가 발생하면 표현 범위 밖의 데이터들은 아예 고려하지 않을 것이다. 왜냐하면 회로가 부족하기 때문이다. 이는 자연스럽게 모듈로 산술을 적용하는 효과로 이어진다.
하지만 MIPS 프로세서는 오버플로우를 탐지하면 예외(exception)를 발생시킨다. 

이를 오버플로우에 대한 대처(fallback)이라고 한다.
오버플로우에 대한 fallback으로는 시계 산술(모듈로 산술), 포화 산술, 트랩(abort) 등이 있다.
이때 fallback을 프로세서에서 제어할 수도 있고 소프트웨어에서 제어할 수도 있다.

소프트웨어 수준의 오버플로우 제어는 컴파일러와 소스코드 수준으로 구분할 수 있다.
gcc의 경우, 내장 함수(builtin funciton)를 사용하거나 컴파일 옵션(-ftrapv, -fwrapv)으로 오버플로우 제어를 설정할 수 있다.
또는 소스코드에서 직접 오버플로우를 탐지하고 제어하는 코드를 추가할 수도 있다.



(중요 숙지사항)
참고로 c언어에서는 2의 보수 여부를 규정하지도 않고, 표현 범위 밖의 연산 결과값에 대해서도 규정하지 않는다.
즉,  c언어에는 오버플로우 제어에 대한 규정이 없어서 이는 구현에 의존적이다(implementation dependant, 구현에 따라 다르다는 뜻이다).

##  기수법 Numeral System
기수법이란, 명칭 그대로 수를 표기하는 방법이다.

기수법은 단항기수법, 명수법, 위치값 기수법으로 구분할 수 있다.

단항기수법(또는 일진법)이란, 수를 나타내는 기호가 1개인 기수법이다.
예를 들어 단위 기호가 $\text{I}$인 경우, $\text{IIIII}$은 자연수 5를 의미한다.
이때 기호의 개수가 곧 해당 수의 크기를 의미한다.

명수법은 명칭 그대로 수에 이름을 붙인다는 뜻으로, 특정 수치에 특정 기호를 대응시키는 것을 의미한다.
단항기수법은 자연수 1에만 기호 $\text{I}$를 대응시켰다고 볼 수 있으며, 명수법은 여러 수치에 기호를 대응시킨다고 볼 수 있다.

명수법의 가장 대표적인 예시로 로마 숫자(또는 로마 기수법, roman numerals)가 있다.
로마 기수법에서는 자연수 1을 $\text{I}$로, 자연수 10를 $\text{X}$로, 자연수 100을 $\text{M}$으로 표기한다.
예를 들어 자연수 321의 로마 숫자는 $\text{CCCXXI}$이다.

로마 기수법은 수를 표현하는 기호의 개수를 줄이기 위해 특수한 규칙을 사용하며, 이때 기호들의 순서가 매우 중요하다.
예를 들어 44를 로마 기수법으로 표기하면 $\text{XLIV}$이다.
이는 $\text{XXXXIIII}$를 축약하기 위함이다.
이때 $\text{XLIV}$의 문자들 중 어느 것이라도 순서가 바뀌면 그 값도 바뀌게 된다.

**하지만 이 글에서는 논의의 편의를 위해 명수법이 기호들의 위치 순서를 고려하지 않는다고 가정한다.**
즉, $\text{CCCXXI}$나 $\text{CXCIXC}$도 모두 321의 값으로 해석한다.

따라서 만약 기호들의 순서가 표기 규칙과 무관하다면, 기호들의 개수에 수치를 곱한 값들의 합이 수치값을 의미한다.

**여기서 중요한 점은 단항기수법이든 (위의 가정을 따르는) 명수법이든 어떤 기호에 대하여 그 기호의 개수가 수치의 크기와 선형적으로 대응한다는 사실이다.**

### 위치값 기수법 Positional notation
현대 아라비아 숫자 체계의 기수법은 위치값 기수법을 전제한다.

위치값 기수법은 숫자 기호의 위치들에 계수(coefficient)를 부여한다.
그리고 숫자열의 수치값은 해당 위치의 숫자 기호의 수치만큼 그 위치의 계수를 합한 값이다.

예를 들어 10진법 숫자열 "321"의 경우, 숫자 기호 3의 계수는 100, 2의 계수는 10, 1의 계수는 1이다.

자연수 321의 로마 숫자가 "CCCXXI"인 것을 감안하면, 10진법에서 숫자의 위치는 단위 기호의 크기를, 해당 위치에 있는 숫자의 크기는 해당 단위 기호의 개수를 의미한다고 볼 수 있다.
이때 10진법에서의 계수들은 10의 양의 정수만큼 거듭제곱한 값들만 가능하다.

일반적으로 수열이나 문자열의 원소들의 순서를 나타낼 때 첨수를 사용할 경우, 자연수 1부터 해당 수열이나 문자열의 길이 $n$까지 부여한다.
예를 들어 $\psi_1, \psi_2, \cdots, \psi_n$ 이런 식이다.

하지만 위치값 기수법에서는 숫자열의 길이 $w$에 대하여 원소의 첨수를 다음과 같이 정의할 수 있다(단 $w$는 숫자열의 너비 width의 머리글자를 따서 표기한 것이다).

$$
\psi_{w-1}\psi_{w-2} \cdots \psi_{1}\psi_{0}
$$

첨수의 순서가 rtl(right to left)인 이유는 자릿수 확장이 오른쪽에서 왼쪽으로 이루어지는 아라비아 표기법을 그대로 따르는 것이다.

첨수의 순서가 rtl이냐 ltr이냐의 문제는 표기법의 문제에 불과하다. 예를 들어 십진수 위치 표기법을 적용한 숫자열 $321$을 ltr(left to right)으로 표기하면 $123$이 된다. 하지만 인코딩이 다를 뿐, 두 숫자열 모두 자연수 321을 의미한다. 이 글에서는 일반적으로 통용되는 숫자 표기 순서인 rtl을 전제한다.

첨수의 값은 해당 원소의 계수를 암시한다.
각 숫자 위치의 첨수값에 대하여 기수(radix)를 그 첨수값만큼 제곱하면 계수(coefficient)가 나오기 때문이다.

다음은 기수가 $r$이고 길이가 $w$인 위치값 기수법 숫자열 $\psi^{r}$의 수치를 계산하는 함수의 공식이다.
이때 $\psi_{i}$는 $i$ 위치의 숫자 기호의 값을 의미한다.

$$
\tau \left( \psi^{r} \right) = \sum\limits_{i=0}^{w-1} { \psi_{i} \cdot r^{i}}
$$

    (그림 필요)

### 정리
명수법과 위치값 기수법 모두 큰 숫자를 최대한 압축적으로 표기하기 위해 고안된 표기법들이다.
숫자열의 길이를 줄이기 위해 두 방법 모두 적절한 큰 수들을 단위로 정하고, 단위와 정확하게 일치하지 않는 수는 크고 작은 단위들을 조합하는 방식으로 수를 표기한다.

이때 수의 단위와 단위의 개수는 명수법과 위치값 기수법에서 다음에 대응한다.
*   명수법: 내용(단위의 값), 개수
*   위치값 기수법: 위치, 내용

그리고 개수, 위치, 내용(값) 모두 자연수로 표현 가능하다.


##  비트 벡터 Bit Vector
이진수는 어떤 수를 $r=2$이고 표기 숫자가 $0$과 $1$인 위치값 기수법으로 표기한 숫자열이다.
이때 이진수를 형식적인 관점에서 숫자열 대신 비트열(bit sequence)이라고 부를 수 있다.
그리고 이진수 표기에 사용하는 숫자 $0$과 $1$은 비트라고 부른다.

숫자열의 숫자로 구성된 행벡터로 표현할 수 있는데, 마찬가지로 비트열도 비트 벡터로 표현할 수 있다.
단, 이때 표기에 사용하는 숫자는 모두 숫자가 아니라 수로 취급한다.

$$
\vec{x} = [x_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ w \  \}} \; = [ x_{w-1}, ..., x_0 ] \; \left(  \forall x_i \in \{ x_i \in \mathbb{Z^+} \ | \ x_i < r \} \right)
$$

이때 1바이트(8비트) 비트 벡터의 $w$ 값은 8이며 이는 다음과 같이 정의할 수 있다.
$$
\vec{b} = [b_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ 8 \  \}} \; = [ b_{7}, ..., b_0 ] \; \left(  \forall b_i \in \{ 0, 1 \} \right)
$$

비트 벡터에 대하여 $i$번째 원소 $b_i$ 를 $i$번째 비트라고 한다.

그리고 $b$의 너비(또는 길이) $b$에 대하여 $b_0$를 최하위 비트(LSB, Least Significant Bit), $b_{w-1}$를 최상위 비트(MSB, Most Significant Bit)라고 한다.

###   비트 벡터와 유한집합 인코딩
비트 벡터를 사용하여 유한집합을 인코딩할 수도 있다.

예를 들어 비트 벡터가 $[0,1,1,0,1,0,0,1]$이라면, 이는 양의 정수에 대한 임의의 유한집합 $A= \left\{ 0, 3, 5, 6 \right\}$를 인코딩한다.

즉, 유한집합 인코딩에서는 비트 벡터의 위치값(또는 순서값)이 양의 정수 유한집합의 원소를 의미한다.

### 비트 연산 Bitwise Operation
Boolean Algebra의 연산을 정의하는 방법에는 조각적 정의 함수(piecewise-defined function)로 정의하는 방법과 Tarski(1953)의 방법이 있다.

Tarski의 정의는 해석적이지만 진리값이 자연수가 아니면 사용할 수 없다.
즉, 진리값 연산이 자연수 연산을 전제한다.
반면 조각적 정의 함수를 이용한 정의는 진리값이 자연수가 아니어도 사용할 수 있다.
즉, 아래 정의에서는 진리값으로 $1$과 $0$을 사용했지만 이를 문자열 "True"와 "False"로 치환해도 성립한다.

####    Operation defitions with piecewise-defined function

*
   $$
   a \wedge b = \begin{cases}
      1 &\text{if } a=b=1 \\
      0 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \vee b = \begin{cases}
      0 &\text{if } a=b=0 \; \\
      1 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \veebar b = \begin{cases}
      0 &\text{if } a=b \quad \quad \\
      1 &\text{else}
   \end{cases} 
   $$
*  
   $$
   \neg \ a = \begin{cases}
      0 &\text{if } a=1 \quad \;\ \\
      1 &\text{else}
   \end{cases} 
   $$

####    Operation Definitions of Tarski
*   $a \wedge b =\text{min}(a,b) \;  = \; a \times b $
*   $a \vee b = \text{max}(a,b) \; = a+b - a \times b $
*   $ a \veebar b = (a-b)^2$
*   $ \neg \; a \;\ = 1-a$

참고로 $a+b$ 식만으로는 비트 연산을 정의할 수 없다. $a=1, \; b=1$일 때 $a+b$는 수의 범위를 벗어나기 때문이다.
$a-b$ 식도 a=0, b=1일 때 값이 -1이 되므로 이 역시 단일로 정의될 수 없다.

+  그 외 연산의 성질, 드모르간 법칙

####    시프트 연산
비트 벡터에 대한 시프트 연산을 수학적으로 정의하는 것은 우아하지 못하다.

*   logical left shit
*   logical right shift
*   arithmetic right shit

### 알고리즘: 비트마스크
내용 나중에 추가

##  Boolean Algebra and Boolean Ring
(difference between Boolean Algebra and Boolean Ring)


##  정수 Integer

### 정수 인코딩

####    부호 없는 정수  Unsigned Integer
크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$에 대하여 부호 없는 정수 인코딩에서 가지는 값은 다음과 같이 계산할 수 있다.

$$
B2U_{w} \left( \vec{x} \right) \doteq \sum\limits_{i=0}^{w-1} { x_{i} \cdot 2^{i}}
$$

이는 위치기수법에서 숫자열의 수치값을 구하는 공식과 같다.

    그림

####    부호 있는 정수  Signed Integer
일반적으로 십진수 음수를 표기할 때 우리는 숫자열 좌측에 $-$ 기호를 붙인다.
음의 이진수 역시 숫자열 좌측에 $-$ 기호를 붙이는 방법으로 표기할 수 있지만, 메모리에 음수를 저장할 때는 0과 1을 제외한 다른 값을 사용할 수가 없다.

0과 1만으로 양의 정수와 음의 정수를 모두 표현하기 위한 인코딩 방법을 **부호 있는 정수(Signed Integer)**라고 한다. 부호 있는 정수 인코딩에는 **부호 절대값(Signed Magnitude)**, **1의 보수(One's Complement)** 그리고 **2의 보수(Two's Complement)**가 있다.

####    부호 절대값     Signed Magnitude
부호 절대값 인코딩은 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 지정하고 나머지 비트는 부호 없는 정수와 동일한 인코딩을 적용한다.

이는 사람 입장에서 비트열을 보고 해당 비트열의 정수 값을 직관적으로 계산할 수 있다는 장점이 있다.
하지만 기계 입장에서는 정수의 부호를 전환하거나 뺄셈 연산을 할 때 상대적으로 많은 비용이 발생한다는 단점이 있다.
또한 1의 보수와 마찬가지로 0의 값이 2개이므로 표현할 수 있는 정수의 범위가 2의 보수보다 1단위 적다.

크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$의 부호 절대값 인코딩의 정수값은 다음과 같이 계산한다.

$$
B2S_{w} \left( \vec{x} \right) \doteq \left( - 1 \right)^{ x_{w-1} } \cdot \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

####    1의 보수    One's Complement

    (주판과 보수)

1의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  더한 값의 최하위 비트에 캐리 비트의 값을 더한다.

$$
B2O_{w} \left( \vec{x} \right) \doteq -x_{w-1} \left( 2^{w-1} - 1 \right) + \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

1의 보수와 2의 보수 모두 어떤 비트 벡터를 가지는 정수에 대하여 그 덧셈의 역원과 덧셈 연산을 수행할 때 그 결과값이 항상 0이 나와야 한다.

1의 보수 인코딩은 임의의 정수와 그 역원의 합이 -0의 비트값을 가지는 반면, 2의 보수법은 0의 값을 가지는 비트 벡터가 하나이므로 그 역원과의 합이 0의 비트값을 가진다.

1의 보수 인코딩의 경우, 부호 반전이 매우 간단하다. 비트 반전이 곧 부호 반전이기 때문이다.
하지만 2의 보수와 달리 뺄셈에서 캐리값을 버릴 수 없어서 구현이 상대적으로 복잡하고, 부호 절대값 인코딩처럼 정수의 표현 범위가 2의 보수 인코딩보다 1단위 더 작다.

####    2의 보수       Two's Complement
크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$ 에 대하여 그 비트 벡터의 부호 없는 정수값 $x$을 $2^w$에서 뺀 값 $2^w - x$이 있다고 하자.
이때 $2^w - x$을 부호 없는 정수 인코딩으로 매핑한 비트 벡터가 2의 보수 인코딩에서 정수 $x$의 덧셈에 대한 역원 $-x$의 비트 벡터와 같다. (이때 $\textrm{TMIN}_w$은 역원을 가지지 않으므로 예외이다)

"2의 보수 인코딩"이라는 명칭에서 "2의 보수"라는 표현은 위의 맥락을 반영한다.

2의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  캐리 값은 버린다.

따라서 뺄셈 연산이 1의 보수 인코딩보다 더 간단하다.
또한  2의 보수 인코딩은 다른 부호 있는 정수 인코딩과 달리 정수 0에 매핑되는 비트 벡터가 하나이므로 표현 범위가 부호 최대치 및 1의 보수 인코딩보다 1단위 더 크다.
대신 부호 전환이 1의 보수보다 비교적 번거롭다.

하지만 2의 보수 인코딩의 장점이 다른 부호 있는 인코딩을 압도하므로, 대부분의 시스템에서 정수의 비트 표현 방법으로 2의 보수 인코딩을 채택한다고 여겨도 무방하다.

$$
B2T_{w} \left( \vec{x} \right) \doteq -x_{w-1} \cdot 2^{w-1} +  \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

### 부호 있는 정수와 부호 없는 정수 간의 변환(conversion)

### 정수의 비트 확장(extension)

### 정수의 비트 절삭(truncate)

##  정수의 산술 연산 Integer Arithmetic

##  부동소수점수
부동소수점수는 무리수를 표현할 수 없다. 대신 근사할 수 있을 뿐이다.

### 근사법 rounding

### 부동소수점수 연산