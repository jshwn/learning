#   비트열의 표현

##  기수법 Numeral System
기수법이란, 명칭 그대로 수를 표기하는 방법이다.

기수법은 단항기수법, 명수법, 위치값 기수법으로 구분할 수 있다.

단항기수법(또는 일진법)이란, 수를 나타내는 기호가 1개인 기수법이다.
예를 들어 단위 기호가 $\text{I}$인 경우, $\text{IIIII}$은 자연수 5를 의미한다.
이때 기호의 개수가 곧 해당 수의 크기를 의미한다.

명수법은 명칭 그대로 수에 이름을 붙인다는 뜻으로, 특정 수치에 특정 기호를 대응시키는 것을 의미한다.
단항기수법은 자연수 1에만 기호 $\text{I}$를 대응시켰다고 볼 수 있으며, 명수법은 여러 수치에 기호를 대응시킨다고 볼 수 있다.

명수법의 가장 대표적인 예시로 로마 숫자(또는 로마 기수법, roman numerals)가 있다.
로마 기수법에서는 자연수 1을 $\text{I}$로, 자연수 10를 $\text{X}$로, 자연수 100을 $\text{M}$으로 표기한다.
예를 들어 자연수 321의 로마 숫자는 $\text{CCCXXI}$이다.

로마 기수법은 수를 표현하는 기호의 개수를 줄이기 위해 특수한 규칙을 사용하며, 이때 기호들의 순서가 매우 중요하다.
예를 들어 44를 로마 기수법으로 표기하면 $\text{XLIV}$이다.
이는 $\text{XXXXIIII}$를 축약하기 위함이다.
이때 $\text{XLIV}$의 문자들 중 어느 것이라도 순서가 바뀌면 그 값도 바뀌게 된다.

**하지만 이 글에서는 논의의 편의를 위해 명수법이 기호들의 위치 순서를 고려하지 않는다고 가정한다.**

즉, $\text{CCCXXI}$나 $\text{CXCIXC}$도 모두 321의 값으로 취급한다.

만약 기호들의 순서가 표기 규칙과 무관하다면, 기호들의 개수에 수치를 곱한 값들의 합이 문자열이 가지는 수치값을 의마하게 된다.

**여기서 중요한 사실은, 단항기수법과 (위의 가정을 따르는) 명수법은 어떤 기호에 대하여 그 기호의 개수가 수치의 크기와 선형적으로 대응한다는 것이다.**

하지만 이러한 표기법은 수치의 크기가 커지면 그에 대응하여 문자열의 길이도 필연적으로 길어지는 한계를 가진다. 명수법도 결국 더 큰 수치 단위를 구분할 수 있는 기호를 도입하지 못하면, 업도적으론 큰 수치를 표기하는 데에 있어서 단항기수법과 큰 차이가 없다.

### 위치값 기수법 Positional notation
현대 아라비아 숫자 체계의 기수법은 위치값 기수법을 전제한다.

위치값 기수법은 숫자 기호의 위치들에 계수(coefficient)를 부여한다.
그리고 숫자열의 수치값은 해당 위치의 숫자 기호의 수치만큼 그 위치의 계수를 합한 값이다.

예를 들어 10진법 숫자열 "321"의 경우, 숫자 기호 3의 계수는 100, 2의 계수는 10, 1의 계수는 1이다.

자연수 321의 로마 숫자가 "CCCXXI"인 것을 감안하면, 10진법에서 숫자의 위치는 단위 기호의 크기를, 해당 위치에 있는 숫자의 크기는 해당 단위 기호의 개수를 의미한다고 볼 수 있다.
이때 10진법에서의 계수들은 10의 양의 정수만큼 거듭제곱한 값들만 가능하다.

일반적으로 수열이나 문자열의 원소들의 순서를 나타낼 때 첨수를 사용할 경우, 자연수 1부터 해당 수열이나 문자열의 길이 $n$까지 부여한다.
예를 들어 $\psi_1, \psi_2, \cdots, \psi_n$ 이런 식이다.

하지만 위치값 기수법에서는 숫자열의 길이 $w$에 대하여 원소의 첨수를 다음과 같이 정의할 수 있다(단 $w$는 숫자열의 너비 width의 머리글자를 따서 표기한 것이다).

$$
\psi_{w-1}\psi_{w-2} \cdots \psi_{1}\psi_{0}
$$

첨수의 순서가 rtl(right to left)인 이유는 자릿수 확장이 오른쪽에서 왼쪽으로 이루어지는 아라비아 표기법을 그대로 따르는 것이다.

첨수의 순서가 rtl이냐 ltr이냐의 문제는 표기법의 문제에 불과하다. 예를 들어 십진수 위치 표기법을 적용한 숫자열 $321$을 ltr(left to right)으로 표기하면 $123$이 된다. 하지만 인코딩이 다를 뿐, 두 숫자열 모두 자연수 321을 의미한다. 이 글에서는 일반적으로 통용되는 숫자 표기 순서인 rtl을 전제한다.

첨수의 값은 해당 원소의 계수를 암시한다.
각 숫자 위치의 첨수값에 대하여 기수(radix)를 그 첨수값만큼 제곱하면 계수(coefficient)가 나오기 때문이다.

다음은 기수가 $r$이고 길이가 $w$인 위치값 기수법 숫자열 $\psi^{r}$의 수치를 계산하는 함수의 공식이다.
이때 $\psi_{i}$는 $i$ 위치의 숫자 기호의 값을 의미한다.

$$
\tau \left( \psi^{r} \right) = \sum\limits_{i=0}^{w-1} { \psi_{i} \cdot r^{i}}
$$

    (그림 필요)

### 정리
명수법과 위치값 기수법 모두 큰 숫자를 최대한 압축적으로 표기하기 위해 고안된 표기법들이다.
숫자열의 길이를 줄이기 위해 두 방법 모두 적절한 큰 수들을 단위로 정하고, 단위와 정확하게 일치하지 않는 수는 크고 작은 단위들을 조합하는 방식으로 수를 표기한다.

이때 수의 단위와 단위의 개수는 명수법과 위치값 기수법에서 다음에 대응한다.
*   명수법: 내용(단위의 값), 개수
*   위치값 기수법: 위치, 내용

그리고 개수, 위치, 내용(값) 모두 자연수로 표현 가능하다.


##  비트 벡터 Bit Vector
이진수는 어떤 수를 표기 숫자가 $0$과 $1$인 $r=2$ 위치값 기수법으로 표기한 숫자열이다.
이때 이진수를 형식적인 관점에서 숫자열 대신 비트열(bit string 또는 bit sequence)이라고 부를 수 있다.
그리고 이진수 표기에 사용하는 숫자 $0$과 $1$은 비트라고 부른다.

숫자열의 숫자로 구성된 행벡터로 표현할 수 있는데, 마찬가지로 비트열도 비트 벡터로 표현할 수 있다.
단, 이때 표기에 사용하는 숫자는 모두 숫자가 아니라 수로 취급한다.

$$
\vec{x} = [x_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ w \  \}} \; = [ x_{w-1}, ..., x_0 ] \; \left(  \forall x_i \in \{ x_i \in \mathbb{Z^+} \ | \ x_i < r \} \right)
$$

이때 1바이트(8비트) 비트 벡터의 $w$ 값은 8이며 이는 다음과 같이 정의할 수 있다.
$$
\vec{b} = [b_i]_{i \in \{ i \in \mathbb{Z^+} \ | \ i \ < \ 8 \  \}} \; = [ b_{7}, ..., b_0 ] \; \left(  \forall b_i \in \{ 0, 1 \} \right)
$$

비트 벡터에 대하여 $i$번째 원소 $b_i$ 를 $i$번째 비트라고 한다.

그리고 $b$의 너비(또는 길이) $b$에 대하여 $b_0$를 최하위 비트(LSB, Least Significant Bit), $b_{w-1}$를 최상위 비트(MSB, Most Significant Bit)라고 한다.

### 비트 벡터와 유한집합 인코딩
비트 벡터를 사용하여 유한집합을 인코딩할 수도 있다.

예를 들어 비트 벡터가 $[0,1,1,0,1,0,0,1]$이라면, 이는 양의 정수에 대한 임의의 유한집합 $A= \left\{ 0, 3, 5, 6 \right\}$를 인코딩한다.

즉, 유한집합 인코딩에서는 비트 벡터의 위치값(또는 순서값)이 양의 정수 유한집합의 원소를 의미한다.

배열의 인덱스를 원소의 key로, 배열의 값을 key에 대응하는 value로 사용하는 것 역시 이와 똑같은 방법이다.

##  비트 연산 Bitwise Operation
Boolean Algebra의 연산을 정의하는 방법에는 조각적 정의 함수(piecewise-defined function)로 정의하는 방법과 Tarski(1953)의 방법이 있다.

Tarski의 정의는 해석적이지만 진리값이 자연수가 아니면 사용할 수 없다.
즉, 진리값 연산이 자연수 연산을 전제한다.
반면 조각적 정의 함수를 이용한 정의는 진리값이 자연수가 아니어도 사용할 수 있다.
즉, 아래 정의에서는 진리값으로 $1$과 $0$을 사용했지만 이를 문자열 "True"와 "False"로 치환해도 성립한다.

### Operation defitions with piecewise-defined function

*
   $$
   a \wedge b = \begin{cases}
      1 &\text{if } a=b=1 \\
      0 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \vee b = \begin{cases}
      0 &\text{if } a=b=0 \; \\
      1 &\text{else}
   \end{cases} 
   $$

*  
   $$
   a \veebar b = \begin{cases}
      0 &\text{if } a=b \quad \quad \\
      1 &\text{else}
   \end{cases} 
   $$
*  
   $$
   \neg \ a = \begin{cases}
      0 &\text{if } a=1 \quad \;\ \\
      1 &\text{else}
   \end{cases} 
   $$

### Operation Definitions of Tarski
*   $a \wedge b =\text{min}(a,b) \;  = \; a \times b $
*   $a \vee b = \text{max}(a,b) \; = a+b - a \times b $
*   $ a \veebar b = (a-b)^2$
*   $ \neg \; a \;\ = 1-a$

참고로 $a+b$ 식만으로는 비트 연산을 정의할 수 없다. $a=1, \; b=1$일 때 $a+b$는 수의 범위를 벗어나기 때문이다.
$a-b$ 식도 a=0, b=1일 때 값이 -1이 되므로 정의할 수 없다.

+  그 외 연산의 성질, 드모르간 법칙

### 시프트 연산
시프트 연산은 컴퓨터 시스템에서 취급하는 연산이다. 따라서 비트 벡터에 대한 시프트 연산을 수학적으로 정의하려는 시도는 실익이 없다.

시프트 연산의 종류는 다음과 같이 크게 3가지로 분류할 수 있다.
1. 논리 시프트 연산 (logical shift)
2. 산술 시프트 연산 (arithmetic shift)
3. 순환 시프트 연산 (circular shift)

이중 산술 시프트 연산은 형식적으로는 비트 연산이나, 연산의 목적이 정수의 2의 거듭제곱 또는 이의 역연산이다. 따라서 이에 대한 내용은 후술한다.

##  알고리즘: 비트마스킹
비트마스킹이라는 표현 자체는 비트 조작을 의미하나, 알고리즘 분야에서는 비트 연산을 활용하여 집합 연산을 구현하는 방법으로 통용된다.

* 교집합 $\cap$ 연산은 AND 연산 $\wedge$
* 합집합 $\cup$ 연산은 OR 연산 $\vee$
* 차집합 $\diagdown$ 연산은 XOR 연산 $\veebar$
* 여집합 $\complement$ 연산은 NOT 연산 $\neg$
* 기타 부분집합 여부는 나중에 계속

##  Boolean Algebra and Boolean Ring
전술한 비트마스킹의 내용을 보면 집합의 연산과 비트 연산이 대응되는 것을 알 수 있다.

엄밀하게 말하면, 임의의 유한집합의 멱집합에 대해 집합연산이 정의된 대수 구조는 부울 대수에 해당한다.

전술한 bitwise operation은 원소가 0과 1인 집합 위에 정의된 부울 대수의 연산이다.

그리고 부울 대수는 부울 환과 동형이다.

부울 대수와 부울 환의 차이는 연산의 쌍대성(duality) 여부이다.
부울 대수의 $\wedge$와 $\vee$ 연산은 서로 쌍대적이지만, 부울 환의 $\cdot$와 $\oplus$ 연산은 쌍대적이지 않다.

정확하게 말하자면, 부울 환에서는 연산들이 서로 대칭적일 필요가 없다는 것이다. 부울 환은 부울 대수를 환의 조건으로 완화한 대수 구조라고 보면 된다.

결론적으로 부울 환에서 부울 대수를 유도할 수 있다는 뜻이다.

## 소결
이번 글에서는 비트열과 이에 대한 연산을 수학적으로 엄밀하게 접근해보았다.

이러한 접근은 컴퓨터 시스템에서 정의한 비트열과 이에 대한 연산이 특정 대수 구조를 따른다는 점에서 수학적으로 예측가능하며, 따라서 신뢰가능하다는 것을 이해할 수 있다는 점에서 의의가 크다.