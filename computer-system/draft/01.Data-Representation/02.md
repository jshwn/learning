#   정수의 표현

##  정수 인코딩

### 부호 없는 정수  Unsigned Integer
크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$에 대하여 부호 없는 정수 인코딩에서 가지는 값은 다음과 같이 계산할 수 있다.

$$
B2U_{w} \left( \vec{x} \right) \doteq \sum\limits_{i=0}^{w-1} { x_{i} \cdot 2^{i}}
$$

이는 위치기수법에서 숫자열의 수치값을 구하는 공식과 같다.

    그림

### 부호 있는 정수  Signed Integer
일반적으로 십진수 음수를 표기할 때 우리는 숫자열 좌측에 $-$ 기호를 붙인다.
음의 이진수 역시 숫자열 좌측에 $-$ 기호를 붙이는 방법으로 표기할 수 있지만, 메모리에 음수를 저장할 때는 0과 1을 제외한 다른 값을 사용할 수가 없다.

0과 1만으로 양의 정수와 음의 정수를 모두 표현하기 위한 인코딩 방법을 **부호 있는 정수(Signed Integer)**라고 한다. 부호 있는 정수 인코딩에는 **부호 절대값(Signed Magnitude)**, **1의 보수(One's Complement)** 그리고 **2의 보수(Two's Complement)**가 있다.

### 부호 절대값     Signed Magnitude
부호 절대값 인코딩은 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 지정하고 나머지 비트는 부호 없는 정수와 동일한 인코딩을 적용한다.

이는 사람 입장에서 비트열을 보고 해당 비트열의 정수 값을 직관적으로 계산할 수 있다는 장점이 있다.
하지만 기계 입장에서는 정수의 부호를 전환하거나 뺄셈 연산을 할 때 상대적으로 많은 비용이 발생한다는 단점이 있다.
또한 1의 보수와 마찬가지로 0의 값이 2개이므로 표현할 수 있는 정수의 범위가 2의 보수보다 1단위 적다.

크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$의 부호 절대값 인코딩의 정수값은 다음과 같이 계산한다.

$$
B2S_{w} \left( \vec{x} \right) \doteq \left( - 1 \right)^{ x_{w-1} } \cdot \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

### 1의 보수    One's Complement

    (주판과 보수)

1의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  더한 값의 최하위 비트에 캐리 비트의 값을 더한다.

$$
B2O_{w} \left( \vec{x} \right) \doteq -x_{w-1} \left( 2^{w-1} - 1 \right) + \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

1의 보수와 2의 보수 모두 어떤 비트 벡터를 가지는 정수에 대하여 그 덧셈의 역원과 덧셈 연산을 수행할 때 그 결과값이 항상 0이 나와야 한다.

1의 보수 인코딩은 임의의 정수와 그 역원의 합이 -0의 비트값을 가지는 반면, 2의 보수법은 0의 값을 가지는 비트 벡터가 하나이므로 그 역원과의 합이 0의 비트값을 가진다.

1의 보수 인코딩의 경우, 부호 반전이 매우 간단하다. 비트 반전이 곧 부호 반전이기 때문이다.
하지만 2의 보수와 달리 뺄셈에서 캐리값을 버릴 수 없어서 구현이 상대적으로 복잡하고, 부호 절대값 인코딩처럼 정수의 표현 범위가 2의 보수 인코딩보다 1단위 더 작다.

### 2의 보수       Two's Complement
크기가 자연수 $w$인 임의의 비트 벡터 $\vec{x}$ 에 대하여 그 비트 벡터의 부호 없는 정수값 $x$을 $2^w$에서 뺀 값 $2^w - x$이 있다고 하자.
이때 $2^w - x$을 부호 없는 정수 인코딩으로 매핑한 비트 벡터가 2의 보수 인코딩에서 정수 $x$의 덧셈에 대한 역원 $-x$의 비트 벡터와 같다. (이때 $\textrm{TMIN}_w$은 역원을 가지지 않으므로 예외이다)

"2의 보수 인코딩"이라는 명칭에서 "2의 보수"라는 표현은 위의 맥락을 반영한다.

2의 보수 인코딩에서 뺄셈은 다음과 같이 수행된다.

1.  우항의 비트값을 반전시킨다.
2.  좌항과 우항의 비트값을 더한다.
3.  캐리 값은 버린다.

따라서 뺄셈 연산이 1의 보수 인코딩보다 더 간단하다.
또한  2의 보수 인코딩은 다른 부호 있는 정수 인코딩과 달리 정수 0에 매핑되는 비트 벡터가 하나이므로 표현 범위가 부호 최대치 및 1의 보수 인코딩보다 1단위 더 크다.
대신 부호 전환이 1의 보수보다 비교적 번거롭다.

하지만 2의 보수 인코딩의 장점이 다른 부호 있는 인코딩을 압도하므로, 대부분의 시스템에서 정수의 비트 표현 방법으로 2의 보수 인코딩을 채택한다고 여겨도 무방하다.

$$
B2T_{w} \left( \vec{x} \right) \doteq -x_{w-1} \cdot 2^{w-1} +  \sum\limits_{i=0}^{w-2} {x_i \cdot 2^{i}}
$$

    그림

### 부호 있는 정수와 부호 없는 정수 간의 변환(conversion)

### 정수의 비트 확장(extension)

### 정수의 비트 절삭(truncate)

##  정수의 산술 연산 Integer Arithmetic

##  정수의 덧셈

##  정수의 곱셈

##  정수의 나눗셈