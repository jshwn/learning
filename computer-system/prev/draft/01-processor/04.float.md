#   Float Arithmetic

##  과학적 기수법 Scientific Notation
$$
7, 7 \times 10^0    \\
123.456, 1.23456 \times 10^3
$$
*   과학적 기수법: 소수점의 왼쪽에는 한 자릿수만이 나타나게 하는 표기법
*   정규화된 수 normalized number: 선행하는 0이 없는 부동 소수점 표기법

소수 부분(fraction) vs 지수 부분(exponent)
(여기서는 소수부 vs 지수부라고 표현)
정밀도 vs 표현 범위

정규화된 형태의 표준 과학적 표기법

##  실수의 인코딩 (IEE 754)
IEE 754 설계자들은 정수 비교에 의해 쉽게 정렬될 수 있는 부동소수점 표현을 원했다.
만약 지수부를 2의 보수법으로 표기하게 되면, $n \times 2^{-1}$이 매우 큰 수처럼 보일 것이다.
그래서 2의 보수법에서 가장 큰 양의 정수인 011..11을 지수부의 가장 큰 양수가 아니라, 111...11을 가장 큰 지수로 설정한다.

지수를 정렬할 때, 소수부는 당연히 정수 비교를 하는데 지수까지 정수 비교를 하기는 번거로울 것 같다.
그래서 지수는 양수와 음수를 정수 비교하지 않고 한 번에 비교할 수 있도록 조정하는데, 이때 조정하는 값을 bias라고 한다. (나중에 설명 수정 필요)

바이어스된 표기법(biased notation)은 

    단일 정밀도의 경우, bias가 127
    MAX =  127 + 127 = 254 = 1111 1110
    +1  =    1 + 127 = 128 = 1000 0000
    0   =    0 + 127 = 127 = 0111 1111 (bias)
    -1  =   -1 + 127 = 126 = 0111 1110
    MIN = -126 + 127 =   1 = 0000 0001

    참고로 지수부에서 0000 0000(0)과 1111 1111(255)은 예약된 값이다.

단일 정밀도에서 지수부의 값이 255, 기수부의 값이 0인 실수를 무한으로 정의한다.
이 무한대의 목적은 실수의 위상적 닫힘(toppological closure)을 형성하기 위함이다(CODME:p228).



##  실수의 덧셈

### 실수의 덧셈 - 수학적 성질
실수의 덧셈은 교환법칙은 성립하지만 결합법칙은 성립하지 않는다.


### 실수의 덧셈 알고리즘
1.  두 수의 지수부를 비교하여 작은 쪽을 큰 쪽에 맞춤(logical right shift)
2.  두 수의 기수부를 더한다.
3.  두 수의 합을 정규화시킨다(지수부를 조정)
    *   오버플로우나 언더플로우의 경우, 구현에 따라 처리한다(MIPS에서는 에러)
4.  지수부를 자리맞춤(round)한다.
5.  정규화가 되지 않았으면 3으로 돌아간다.

##  실수의 곱셈
1.  두 수의 지수부에서 각각 bias를 뺀 값을 더하여 곱의 지수를 구한다.
2.  두 수의 기수부를 곱한다.
3.  곱한 값을 정규화한다.
4.  지수부를 자리맞춤한다.

이때 CODME에서는 round를 "자리맞춤"으로, CS:APP에서는 "근사"로 번역한다(rounding은 근사법).

##  IEE754 
보호비트, 자리맞춤 비트, ulp
IEE754 자리맞춤 모드: 항상 자리올림, 항상 자리내림, 잘라내기(truncate), 가장 가까운 짝수로의 자리맞춤(round to nearest even)
점착 비트 sticky bit

### IEE754의 근사 모드
*   Round-to-even 짝수근사
*   Round-toward-zero   영방향근사
*   Round-down  하향근사
*   Round-up    상향근사

##  단일 곱셈 누산기
Fused Mulitply Adder, FMA(FMA4까지 나옴)

MAC: Multiply-ACcumulate operation

CODME에서는 곱셈-덧셈 융합이라고 번역함.

##  임의 정밀도 산술
(임의 정밀도 산술 Arbitrary Precision Arithmetic은 어플리케이션 레벨이므로 언급만)


##  x86: SSE와 AVX