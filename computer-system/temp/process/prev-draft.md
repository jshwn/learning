#   Process Memory
(전체적인 맥락을 잡기 위한 글)

##  Memory Layout
이 글에서는 메모리를 순수하게 프로세스, 즉 프로그램을 작성하는 개발자 입장에서 기술한다.

프로세스 메모리는 커널(또는 memory allocator)이 프로세스에 필요한만큼 할당한 주소 공간을 의미한다. 이때 대부분의 현대 컴파일러들은 프로세스가 선형 주소 공간에서 실행될 것을 전제하고 소스 코드를 컴파일하며, 대부분의 현대 커널들은 이에 맞춰 가상의 선형 주소 공간을 부여한다(그 이유와 자세한 내용은 페이징 및 가상 메모리에서 기술한다).

linux 환경에서 C언어로 작성한 소스 코드를 컴파일한 후, `size` 명령어를 실행하면 segment 별로 컴파일된 실행 파일의 크기가 어느 정도인지 확인할 수 있다. 환경에 따라 구체적인 표시 사항은 다를 수 있지만 보통 text, data, bss segment 등을 표시한다. stack과 heap segment는 프로그램 실행 전이므로 표시되지 않는다.

text segment는 바이너리 명령 열들을 저장하며, data segment는 전역 변수 등을 저장한다. 그 외에 bss segment는 전역 변수 중 초기화되지 않은 변수를 저장하며 stack은 stack frame 관련 정보(return pointer와 스택 인자 등)와 지역 변수를 저장하고, heap segment는 동적으로 할당된 데이터를 저장한다.

주소 공간을 일정 구간(세그먼트)으로 나누어 사용하는 것을 세그멘테이션(segmentation)이라고 한다. 데이터를 그 목적에 맞는 세그먼트에 저장하는 것은 주소 공간을 세그먼트로 나누는 것에 해당한다.

그런데 세그먼트를 사용하는 방식은 크게 2가지 있다. 하나는  프로세서에서 세그먼트 레지스터를 지원하고 이를 이용하여 세그먼트의 데이터에 접근하는 것이고, 다른 하나는 일반 메모리에 접근하는 것과 동일하게 사용하는 것이다. 이때 전자를 하드웨어 세그멘테이션이라고 한다.

현대의 커널들은 세그먼트 레지스터를 거의 활용하지 않는다. 세그먼트 레지스터를 이용해 하드웨어 레벨에서 세그먼트를 다루는 것보다 세그먼트를 추상화하는 것이 좀 더 범용적이기 때문이다. 세그먼트 레지스터는 딱 프로세서가 지원하는 수준까지만 사용할 수 있으므로 확장성이 매우 떨어진다.

예를 들어 8086에서는 세그먼트 레지스터로 cs(code segment, text segment와 같다), ds(data segment), ss(stack segment) 그리고 es와 fs(extra segments)를 지원한다. 이 경우 bss segment에 접근하려면 es 또는 fs 레지스터를 사용해야 할 것이다.

과거에 하드웨어 세그멘테이션을 사용할 때는 far pointer와 near pointer 개념이 있었다. 예를 들어 어셈블리 코드에서 어떤 메모리 주소를 `cs:0x03`로 작성할 때, `cs`는 far pointer이고 `0x03`은 near pointer인 것이다. 이때 `cs:0x03`는 cs register가 저장하는 code segment의 base pointer에서 3만큼 떨어진 주소를 의미한다.

이러한 메모리 주소를 논리 주소라고 부른다. 교재에서는 메모리 주소에 접근하려면 논리 주소를 선형 주소로 변환하고 이 선형 주소를 다시 물리 주소로 변환해야 한다고 기술한다. 하지만 이는 강학상 개념으로 현대의 컴파일러 대부분은 앞에서 논한 확장성을 이유로 논리 주소를 사용하지 않는다. 따라서 메모리 주소 접근은 선형 주소(가상 공간에서의 주소)를 물리 주소로 변환하는 과정이라고 이해해도 무방하다.

가상 메모리를 구현하는 방법 중에는 세그멘테이션이 처음 등장했다. "논리 주소"는 가상의 주소라는 의미를 가지고 있는데, 이 당시에 가상 주소는 세그멘테이션에 의해 가상화된 주소밖에 없으므로 자연스럽게 논리 주소는 세그멘테이션으로 가상화된 주소를 지칭하게 되었다.
하지만 이후에 가상 메모리를 구현하는 다른 방법으로 페이징이 등장하면서, 가상 주소를 세그멘테이션으로 가상화된 주소와 페이징으로 가상화된 주소로 구분할 필요가 생겼다. 그래서 전자는 그대로 "논리 주소", 후자는 "선형 주소"라고 부르게 되었다. 따라서 "논리 주소"라는 용어는 혼동의 여지가 있으니 주의해야 한다.

참고로 세그먼트와 섹션은 다르다. 세그먼트와 섹션 모두 프로그램의 일정 부분(또는 구간)을 의미한다는 점에서는 비슷하다. 하지만 섹션은 어셈블리어에서 사용하는 구간 개념이며, 세그먼트는 그보다 추상적인 개념으로 특정 섹션 또는 섹션들의 집합을 지칭한다.

예를 들어 컴파일러는 c언어의 함수 코드들을 각각의 섹션으로 어셈블하지만, 이 섹션들은 모두 text segment에 포함된다.