#   Chapter 1

##  1.1 운영체제가 할 일
(Silberschatz:1.1) 또는 (Silberschatz:pp4-5)

*   사용자 관점: 운영체제를 사용의 용이성을 목적으로 설계
*   시스템 관점: 운영체제를 자원을 효율적이고 공정하게 할당하는 목적과 프로그램 및 기타 입출력 장치를 제어하기 위한 목적으로 설계

##  1.5 자원 관리

### 1.5.1 프로세스 관리, p29
하나의 프로그램은 디스크에 저장된 파일의 내용과 같인 수동적(passive) 개체이지만, 프로세스는 다음에 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적(active) 개체이다.

##  2.7 운영체제 설계 및 구현
### 2.7.1 설계 목표 Design Goals
설계목표는 사용자 관점과 시스템 관점

### 2.7.2 기법과 정책 Mechanism and Policy
p88
한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다.
기법은 어떤 일을 **어떻게** 할 것인가를 결정하는 것이고, 정책은 **무엇**을 할 것인가를 결정하는 것이다.

p89
마이크로 커널 기반 운영체제는 프리미티브 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다.
이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다.
(중략)
반면 Microsoft는 Windows 운영체제를 실행하는 모든 장치에서 전체적인 모양과 느낌을 통일하기 위해 기법과 정책이 밀접해지도록 인코딩 하였다.

### 2.7.3 구현 Implementation

##  2.8 운영체제 구조
*   모놀리식 구조  Monolithic Structure
*   계층적 접근 Layered Approach
*   마이크로커널 MicroKernels
*   모듈 Moudles
*   하이브리드 시스템 Hybrid Systems

### 2.8.3. 마이크로커널
p94
이 방법은 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.
(중략)
마이크로커널 접근법의 한 가지 장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널을 변경할 필요가 없다.

pp94-95
마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에 또한 더욱 높은 보안성과 신뢰성을 제공한다. 만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.

p95
안타깝게도 마이크로 커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다. 두 개 사용자 수준 서비스가 통신해야 하는 경우, 별도의 주소 공간에 서비스가 존재하기 때문에 메세지가 복사되어야 한다. 또한 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

### 2.8.4 모듈
p95
적재가능 커널 모듈(LKM, Loabable Kernel Moudles) 접근법에서 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다.

사견: 계층 구조와 마이크로 커널의 장점만 취하고 단점을 보완하는 방식.

### p98
Darwin은 Mach 트랩과 BSD 시스켐 콜을 사용하는 커널이다.

##  2.10 운영체제 디버깅

### 2.10.4 BCC
BCC stands for BPF Compiler Collection

p109
BCC는 eBPF(extended Berkeley Packet Filter) 도구에 대한 프론트엔드 인터페이스이다.

#   Chapter 3

p119
활성화 레코드(activation record)

p126
스와핑

p135
연쇄적 종료(cascading termination)

## 3.4 프로세스 간 통신
*   정보 공유(information sharing)
*   계산 가속화(computation speedup)
*   모듈성(modularity)