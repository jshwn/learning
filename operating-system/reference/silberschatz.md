#   Chapter 1

##  1.1 운영체제가 할 일
(Silberschatz:1.1) 또는 (Silberschatz:pp4-5)

*   사용자 관점: 운영체제를 사용의 용이성을 목적으로 설계
*   시스템 관점: 운영체제를 자원을 효율적이고 공정하게 할당하는 목적과 프로그램 및 기타 입출력 장치를 제어하기 위한 목적으로 설계

##  1.5 자원 관리

### 1.5.1 프로세스 관리, p29
하나의 프로그램은 디스크에 저장된 파일의 내용과 같인 수동적(passive) 개체이지만, 프로세스는 다음에 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적(active) 개체이다.

##  2.7 운영체제 설계 및 구현
### 2.7.1 설계 목표 Design Goals
설계목표는 사용자 관점과 시스템 관점

### 2.7.2 기법과 정책 Mechanism and Policy
p88
한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다.
기법은 어떤 일을 **어떻게** 할 것인가를 결정하는 것이고, 정책은 **무엇**을 할 것인가를 결정하는 것이다.

p89
마이크로 커널 기반 운영체제는 프리미티브 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다.
이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다.
(중략)
반면 Microsoft는 Windows 운영체제를 실행하는 모든 장치에서 전체적인 모양과 느낌을 통일하기 위해 기법과 정책이 밀접해지도록 인코딩 하였다.

### 2.7.3 구현 Implementation

##  2.8 운영체제 구조
*   모놀리식 구조  Monolithic Structure
*   계층적 접근 Layered Approach
*   마이크로커널 MicroKernels
*   모듈 Moudles
*   하이브리드 시스템 Hybrid Systems

### 2.8.3. 마이크로커널
p94
이 방법은 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.
(중략)
마이크로커널 접근법의 한 가지 장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널을 변경할 필요가 없다.

pp94-95
마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에 또한 더욱 높은 보안성과 신뢰성을 제공한다. 만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.

p95
안타깝게도 마이크로 커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다. 두 개 사용자 수준 서비스가 통신해야 하는 경우, 별도의 주소 공간에 서비스가 존재하기 때문에 메세지가 복사되어야 한다. 또한 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

### 2.8.4 모듈
p95
적재가능 커널 모듈(LKM, Loabable Kernel Moudles) 접근법에서 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다.

사견: 계층 구조와 마이크로 커널의 장점만 취하고 단점을 보완하는 방식.

### p98
Darwin은 Mach 트랩과 BSD 시스켐 콜을 사용하는 커널이다.

##  2.10 운영체제 디버깅

### 2.10.4 BCC
BCC stands for BPF Compiler Collection

p109
BCC는 eBPF(extended Berkeley Packet Filter) 도구에 대한 프론트엔드 인터페이스이다.

#   Chapter 3

p119
활성화 레코드(activation record)

p126
스와핑

p135
연쇄적 종료(cascading termination)

## 3.4 프로세스 간 통신
p137
시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않는 프로세스는 독립적이다.
시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받는 프로세스는 협력적이다.

*   프로세스 간 협력을 허용하는 이유는 다음과 같다.
    *   정보 공유(information sharing)
    *   계산 가속화(computation speedup)
    *   모듈성(modularity)

사견: 정보 공유를 제외하면 프로세스 간 협력(또는 통신)은 계산 가속화와 모듈성을 보조하는 수단이지 그 이유나 목적은 아니라고 생각한다.

노트:
*   IPC 기법들
    *   공유 메모리
    *   메세지 전달
        *   직접 통신 vs 간접 통신
        *   동기식 통신 vs 비동기식 통신
        *   자동 또는 명시적 버퍼링

##  3.6 메시지 전달 시스템에서의 프로세스 간 통신

p145
메시지 전달은 봉쇄형(blocking)이거나 비봉쇄형(nonblocking) 방식으로 전달된다.
이 두 방식은 동기식, 비동기식이라고도 알려져 있다.

*   봉쇄형 보내기: 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.
*   비봉쇄형 보내기: 송신하는 프로세스는 메시지가 메세지를 보내고 작업을 재시작한다.
*   봉쇄형 받기: 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
*   비봉쇄형 받기: 송신하는 프로세스가 유효한 메시지 또는 널(null)을 받는다.

`send()`와 `receive()`가 모두 봉쇄형일 때, 우리는 송신자와 수신자 간에 랑데부(rendezvous)를 하게 된다.

##  3.7 IPC 시스템의 사례
*   POSIX 공유 메모리
*   Mach 메세지 전달
*   Windows ALPC, advanced local procedure call facility
*   pipe

##  3.8 클라이언트 서버 환경에서의 통신
*   socket
*   rpc, remote procedure call

p162
1024 미만의 모든 포트는 well-known 포트로 간주되며 표준 서비스를 구현하는 데 사용된다.


#   Chapter 4

##  4.3 다중 스레드 모델
*   다대일 모델
*   일대일 모델
*   다대다 모델

사견:
다대일 모델에서 유저 스레드 하나가 시스템 콜을 하거나 인터럽트를 일으키면 해당 프로세스(또는 스레드)의 모든 유저 스레드가 블로킹되며, 멀티 코어 시스템에는 유저 스레드를 할당할 수 없다.

##  4.4 스레드 라이브러리
*   POSIX pthrad
*   Windows thread
*   Java thread

##  4.5 암시적 스레딩 Implicit Threading
암묵적 스레딩: 스레딩 생성과 관리 책임을 개발자로부터 컴파일러와 런타임 라이브러리에게 넘겨주는 전략.

사견: 마치 메모리 관리를 Garbage Collector가 해주는 것과 유사하다.

*   thread pool
*   fork-join model
*   OpenMP
*   GCD, Grand Central Dispatch (for Apple)
*   Intel TBB, Thread Building Blocks

##  4.6 스레드와 관련된 문제들 Threading Issues

### 4.6.3 스레드 취소
p208
취소되어야할 스레드를 목적 스레드라고 한다.

*   비동기식 취소(asynchronous cancellation): 한 스레드가 즉시 목적 스레드를 강제 종료시킨다.
*   지연 취소(deferred cancellation): 목적 스레드가 주기적으로 자신이 강제 종료되어야 할지를 점검한다. 이 경우 목적 스레드가 질서정연하게 강제 종료될 수 있는 기회가 만들어진다.

### 4.6.5 스케줄러 액티베이션
(이건 원문을 봐야 이해할 수 있을 듯)

p210
다대다 또는 두 수준 모델을 구현하는 많은 시스템은 사용자와 커널 스레드 사이에 중간 자료구조를 둔다. 이 자료구조는 통산 경량 프로세스 또는 LWP(Light Weight Process)라고 불린다.

p211
커널은 어플리케이션에 가상 처리기(LWP) 집합을 제공하고, 어플리케이션은 유저 스레드를 가상 처리기에 스케줄한다. 커널은 어플리케이션에 대해 특정 이벤트를 알려줘야 하는데, 이 프로시저를 upcall이라고 한다. upcall은 스레드 라이브러리의 upcall에 의해 처리되고, upcall 처리기는 가상 처리기에서 실행되어야 한다.