[다시 풀 문제]
20, 21, 26, 27, 33, 36, 38, 41, 42, 48

#   1장 데이터 모델링의 이해

*   데이터 모델링의 유의점
    *   중복성
    *   유연성
    *   일관성

*   데이터 모델링의 중요성
    *   파급효과(leverage)
    *   복잡한 정보 요구사항의 간결한 표현(Conciseness)
    *   데이터 품질(Data Quality)
        *   중복, 비유연성, 비일관성 방지가 중요

*   데이터 모델링의 3단계
    1.  개념적: 높은 추상화 수준, 업무 중심적, 포괄적인 수준. 
    2.  논리적: 데이터 모델 사상.
    3.  물리적: 특정 DBMS에 의존적

*   DB 독립성 확보 단게와 데이터베이스 스키마 3단계
    1.  외부 단계 - 외부 스키마: 사용자 관점
    2.  개념 단계 - 개념 스키마: 통합적 관점
    3.  내부 단계 - 내부 스키마: 물리적 저장구조

*   좋은 데이터 모델의 요소
    *   완전성
    *   중복 배제
    *   업무 규칙
    *   데이터 재사용
    *   의사소통
    *   통합성

##  엔터티
*   엔터티의 특징(필요조건)
    *   속성 필수: 엔터티는 반드시 속성이 있어야 한다.
    *   관계 필수: 엔터티는 다른 엔터티와 반드시 1개 이상의 관계가 있어야 한다.
    *   업무 필요: 엔터티는 반드시 해당 업무에 필요하고 관리되어야 하는 정보이어야 한다.
    *   업무 필요: 엔터티는 반드시 업무 프로세스에 의해 이용되어야 한다.
    *   식별 가능: 엔터티는 유일한 식별자에 의해 식별 가능해야 한다.
    *   엔터티는 영속적으로 존재하는 인스턴스의 집합이어야 한다.
        +   2개 이상의 인스턴스가 존재해야 한다.

*   엔터티의 종류
    *   기본 엔터티: 독립적으로 생성되는 엔터티 (다른 엔티티로부터 주식별자를 상속받지 않음)
    *   중심 엔터티: 기본 엔티티로부터 파생되고 해당 업무에서 중심적인 역할을 수행.
    *   행위 엔터티: 2개 이상의 부모 엔터티로부터 파생되며, 비즈니스 프로세스 과정에서 생성되는 엔터티
    *   엔티티 종류별 예시
        *   기본 엔티티: 사원, 부서, 고객, 상품, 자재
        *   중심 엔티티: 계약, 사고, 예금원장, 청구, 주문, 매출
        *   행위 엔티티:  주문목록, 사원변경이력

*   엔터티의 식별자 작명 규칙
    *   현업에서 사용하는 업무 용어
    *   약어 지양
    *   단수 명사 (복수, 서술식 지양)
    *   유일성 (vs 일관성)
    *   명확성

##  속성
*   의미
    *   엔터티가 가지는 최소 의미 단위
    *   인스턴스의 구성 요소

*   **엔터티, 인스턴스, 속성, 속성값에 대한 관계**
    *   한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다.
    *   한 개의 엔터티는 두 개 이상의 속성을 갖는다.
    *   한 개의 속성은 한 개의 속성값을 갖는다.

*   속성의 종류
    *   기본 BASIC
    *   설계 DESIGNED: 데이터 모델링 과정에서 업무 규칙화를 위해 발생하는 속성
    *   파생 DERIVED: 다른 속성에 영향을 받아 발생하는 속성. 보통 계산된 값.
    *   속성의 종류별 예시
        *   기본 속성: 제품이름, 제조년월, 제조원가
        *   설계 속성: 약품용기코드
        *   파생 속성: 전체 용기 수(count), 용기의 총 금액 합계(sum)

*   속성 표기법
    *   IE 표기법
    *   Baker 표기법

*   **도메인**: 속성이 가질 수 있는 값의 범위. 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정한다.

##  관계 Relationship
*   의미
    *   엔터티 간 논리적 관련성

*   관계 식별자 작명 규칙
    *   동사형

*   관계 표기법
    *   관계명, 관계차수, 선택성(또는 선택사양) 3가지로 표기
        +   필수는 I, 선택은 O로 표시
    *   ERD 기준: 표기 구분 안 함
        *   존재 관계: 엔터티 간의 상태(소속 관계 등)
        *   행위 관계: 엔터티 간에 발생하는 행위
    *   UML 기준: 표기 구분 함
        *   연관 관계: 실선 표기 (존재 관계와 비슷)
        *   의존 관계: 점선 표기 (행위 관계와 비슷)

*   엔터티 간 관계 체크 사항
    *   연관 규칙이 존재하는가?
    *   정보 조합이 발생하는가?
    *   업무기술서와 징표에 관계연결에 대한 규칙이 서술되어 있는가?
    *   업무기술서와 징표에 관계연결을 가능하게 하는 **동사(Verb)**가 존재하는가?

##  식별자
*   의미
    *   엔터티를 식별할 수 있는 속성

*   식별자의 종류
    *   주식별자: 유일성, 최소성, 대표성 만족.
    *   보조 식별자: 유일성과 최소성만 만족. 참조 관계 연결에 사용 못 함.
    *   내부 식별자 vs 외부 식별자
        *   외부 식별자: 타 엔티티와의 관계를 통해 타 엔티티에서 받아오는 식별자
    *   단일 식별자 vs 복합 식별자
        *   복합 식별자: 둘 이상의 속성으로 구성된 식별자
    *   본질 식별자 vs 인조 식별자
        *   본질 식별자: 업무에 의해 만들어지는 식별자

*   DB 키의 종류
    *   기본키 PK: 엔터티를 대표하는 키. 후보키 중 선정한다.
    *   후보키   : 유일성과 최소성을 만족
    *   슈퍼키   : 유일성만 만족
    *   대체키   : 기본키를 제외한 나머지 후보키
    *   외래키 FK: 

*   주식별자의 특징
    *   유일성: 주식별자에 의해 엔터티 내의 모든 인스턴트들을 유일하게 구분해야 한다.
    *   최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소한의 수가 되어야 한다.
    *   불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 한다.
    *   존재성: 주식별자가 지정되면 반드시 데이터 값이 존재해야 한다 (Null 안 됨)

### 식별자관계와 비식별자관계에 따른 식별자
*   식별자 관계: 자식 주식별자의 구성에 부모 주식별자가 포함된다.
*   비식별자 관계: 자식 주식별자의 일반 속성으로 부모 주식별자가 포함된다.

*   비식별자 관계를 설정해야 하는 경우
    *   부모 엔티티의 참조값이 없어도 자식 엔티티의 인스턴스를 생성할 수 있을 때
    *   엔티티별로 데이터의 생명 주기를 다르게 관리하는 경우
    *   여러 개의 엔터티가 하나의 엔터티로 통합되어 표현되었는데 각각의 엔터티가 별도의 관계를 가질 때

*   식별자관계와 비식별자관계 모델링 순서
    1.  관계 분석
    2.  관계의 강/약 분석: 약한 관계면 비식별자관계 고려
    3.  자식테이블

*   식별자 관계로만 설정할 경우의 문제점
    *   부모의 기본키를 자식이 모두 포함해야하므로, 가장 최하위 자식의 경우 기본키를 구성하는 외래키가 매우 많아진다.
    *   따라서 SQL Where 절에서 비교하는 항목이 증가되어 조인에 참여하는 테입르에 따라 SQL 문장이 길어져 SQL문의 복잡성이 증가할 수 있다.

*   비식별자 관계로만 설정할 경우의 문제점
    *   조상의 주식별자가 손자까지 내려가지 않으므로, 손자 엔티티에서 조상에 접근하려면 손자에서 조상까지 이어지는 관계 순서에 위치한 모든 테이블들에 대해 조인을 수행해야 한다.

##  제약 조건
*   엔티티 무결성 제약 조건: ?
*   도메인 무결성 제약 조건: NOT NULL, DEFAULT, CHECK
*   참조 무결성 제약 조건: FK, CASCADE, NULL

#   2장 데이터 모델과 성능

##  성능 데이터 모델링

*   절차
    1.  정규화를 정확하게 수행
    2.  데이터베이스 용량산정 수행
    3.  데이터베이스에서 발생하는 트랜잭션의 유형을 파악
    4.  용량과 트랜잭션의 유형에 따라 반정규화를 수행
    5.  이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행(반정규화 방법을 적용)

##  정규화
*   갱신 이상 Update Anomalies: 데이터베이스에 연산을 적용하면서 발생하는 이상
    *   삽입 이상
    *   수정 이상
    *   삭제 이상

*   함수적 종속성
    *   함수적 종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다. 
    *   이 때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다.
    *   예: 주민등록번호 -> (이름, 출생지, 주소)

### 정규화 이론
*   1NF
    *   속성의 값은 유일하게 원자값만 허용
    *   다중값 속성을 허용하지 않음
*   2NF
    *   부분 함수 종속성 제거
    *   완전 함수 종속성 만족
*   3NF
    *   이행적 종속성 제거
*   BCNF Boyce-Codd Normal Form
    *   모든 결정자가 항상 후보키가 되도록 릴레이션을 분해

##  반정규화
*   정의
    *   정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
    *   반정규화는 데이터 무결성을 취약하게 만들고, 입력/수정/삭제에 대한 성능을 저하시킨다.

*   필요
    *   데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되는 경우
    *   경로가 너무 멀어 조인으로 인한 성능 저하가 예상되는 경우
    *   칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우

*   절차
    1.  반정규화 대상 조사
    2.  다른 방법유도 검토
        *   Join 대신 View를 사용하여 성능 향상 가능
        *   데이터의 규모 이슈는 클러스터링이나 인덱스 조정을 통해 성능 향상 가능
        *   데이터의 규모 이슈는 파티셔닝(Partitioning) 기법을 통해 성능 향상 가능
        *   로직을 어플리케이션 단에서 구현하거나 데이터 캐싱을 통해 성능 향상 가능
    3.  반정규화 적용
*   종류
    *   칼럼의 반정규화
    *   테이블의 반정규화
        *   중복테이블 추가: 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상
        *   부분테이블 추가: 하나의 테이블을 전체 칼럼 중 자주 이용하는 집중화된 컬럼이 있을 경우, 디스크I/O를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성
        *   이력테이블 추가: 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법
        *   통계테이블 추가: SUM,AVG 등을 미리 수행하여 계산해 둠으로써 조회시 성능을 향상
    *   관계 반정규화(중복관계 추가)
        *   여러 경로를 거쳐 조인이 가능하지만, 성능저하를 예방하기 위해 추가적인 관계를 맺는 방
        *   테이블, 컬럼의 반정규화는 데이터 무결성에 영향을 미치나, 관계의 반정규화는 데이터 무결성을 깨뜨리지 않고도 성능을 향상시킬 수 있는 반정규화의 기법

*   반정규화를 적용할 때는 기본적으로 데이터 무결성이 깨질 가능성이 많이 있기 때문에 반드시 데이터 무결성을 보장할 수 있는 방법을 고려한 이후에 반정규화를 적용하도록 해야 한다.

*   서버 간에 DB가 정규화되어 있는 경우, 조회할 때마다 서버 간 조인이 발생하므로 이때는 빈번하게 조회되는 속성을 각 DB에 공유하여 서버 간 조인을 막는 이른바 속성 반정규화를 통해 성능을 향상시킬 수 있다.

##  대량 데이터에 따른 성능
*   테이블에 대량의 데이터가 집중되는 경우
    *   대량의 데이터를 처리하기 위해 디스크 I/O량이 증가하는 문제 발생
        *   로우 체이닝: 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
        *   로우 마이그레이션: 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 현상
    *   디스크 I/O를 줄이는 방법
        *   수평 분할(로우 기준)
        *   수직 분할(칼럼 기준)

*   Oracle의 파티셔닝 종류
    *   LIST (예: 지역 위치에 따라 파티셔닝 하는 경우)
    *   RANGE (예: 일자별 데이터를 연/월별로 파티셔닝하는 경우)
    *   HASH 
    *   COMPOSITE
    +   LIST PARTITION은 대용량 데이터를 특정값에 따라 분리 저장할 수는 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.

##  데이터베이스의 구조와 성능
*   슈퍼타입/서브타입
    *   성능 저하 원인
        1.  트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union연산에 의해 성능이 저하될 수 있다.
        2.  트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하될 수 있다.
        3.  트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하될 수 있다.
    *   논리 모델에서 물리 모델로의 변환 기술
        1.  개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
        2.  슈퍼타입+서브타입으로 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
        3.  전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성


*   PK/FK 칼럼의 순서와 DB 성능
    *   여러 칼럼으로 구성된 복합 PK의 경우, 각 PK들 중'=', '<>'로 조회되는 PK의 순서를 앞에 두어야 한다.
    +   FK 제약과 FK 인덱스는 다르며 쿼리에서 FK 인덱스를 사용하지 않더라도 FK 인덱스는 조인 시 FULL SCAN을 유발하지 않아 성능 향상에 도움이 된다.