[다시 풀 문제]
6, 8, 10, 15, 20, 21, 29, 30, 33, 35, 37, 40, 41, 42, 48

#   1장 데이터 모델링의 이해

*   데이터 모델링의 유의점
    *   중복성: 
    *   유연성
    *   일관성

*   데이터 모델링의 3단계
    1.  개념적: 높은 추상화 수준, 업무 중심적, 포괄적인 수준
    2.  논리적: 데이터 모델 사상
    3.  물리적: 특정 DBMS에 의존적

*   DB 독립성 확보 단게와 데이터베이스 스키마 3단계
    1.  외부 단계 - 외부 스키마
    2.  개념 단계 - 개념 스키마
    3.  내부 단계 - 내부 스키마

##  엔터티
*   엔터티의 특징(필요조건)
    *   속성 필수: 엔터티는 반드시 속성이 있어야 한다.
    *   관계 필수: 엔터티는 다른 엔터티와 반드시 1개 이상의 관계가 있어야 한다.
    *   업무 필요: 엔터티는 반드시 해당 업무에 필요하고 관리되어야 하는 정보이어야 한다.
    *   업무 필요: 엔터티는 반드시 업무 프로세스에 의해 이용되어야 한다.
    *   식별 가능: 엔터티는 유일한 식별자에 의해 식별 가능해야 한다.
    *   엔터티는 영속적으로 존재하는 인스턴스의 집합이어야 한다.
        +   2개 이상의 인스턴스가 존재해야 한다.

*   엔터티의 종류
    *   기본 엔터티: 독립적으로 생성되는 엔터티
    *   중심 엔터티: ??
    *   행위 엔터티: 2개 이상의 부모 엔터티로부터 파생되며, 비즈니스 프로세스 과정에서 생성되는 엔터티

*   엔터티의 식별자 작명 규칙
    *   현업에서 사용하는 업무 용어
    *   약어 지양
    *   단수 명사 (복수, 서술식 지양)
    *   유일성 (vs 일관성)
    *   명확성

##  속성
*   의미
    *   엔터티가 가지는 최소 의미 단위
    *   인스턴스의 구성 요소

*   엔터티와 속성(어트리뷰트) 간의 관계
    *   ?

*   속성의 종류
    *   기본 BASIC
    *   파생 DERIVED
    *   설계 DESIGNED: 데이터 모델링 과정에서 업무 규칙화를 위해 발생하는 속성

*   속성 표기법
    *   IE 표기법
    *   Baker 표기법

*   **도메인**: 속성이 가질 수 있는 값의 범위. 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정한다.

##  관계 Relationship
*   의미
    *   엔터티 간 논리적 관련성

*   관계 식별자 작명 규칙
    *   동사형

*   관계 표기법
    *   관계명, 관계차수, 선택성(또는 선택사양) 3가지로 표기
        +   필수는 I, 선택은 O로 표시
    *   ERD 기준: 표기 구분 안 함
        *   존재 관계: 엔터티 간의 상태(소속 관계 등)
        *   행위 관계: 엔터티 간에 발생하는 행위
    *   UML 기준: 표기 구분 함
        *   연관 관계: 실선 표기
        *   의존 관계: 점선 표기

*   엔터티 간 관계 체크 사항
    *   연관 규칙이 존재하는가?
    *   정보 조합이 발생하는가?
    *   업무기술서와 징표에 관계연결에 대한 규칙이 서술되어 있는가?
    *   업무기술서와 징표에 관계연결을 가능하게 하는 **동사(Verb)**가 존재하는가?

#   식별자
*   의미
    *   엔터티를 식별할 수 있는 속성

*   식별자의 종류
    *   주식별자
    *   보조 식별자: 유일성과 최소성만 만족. 참조 관계 연결에 사용 못 함.
    *   내부 식별자 vs 외부 식별자
    *   단일 식별자 vs 복합 식별자

*   DB 키의 종류
    *   기본키 PK: 엔터티를 대표하는 키. 후보키 중 선정한다.
    *   후보키   : 유일성과 최초성을 만족
    *   슈퍼키   : 유일성만 만족
    *   대체키   : 기본키를 제외한 나머지 후보키
    *   외래키 FK: 

*   주식별자의 특징
    *   유일성: 주식별자에 의해 엔터티 내의 모든 인스턴트들을 유일하게 구분해야 한다.
    *   최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소한의 수가 되어야 한다.
    *   불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 한다.
    *   존재성: 주식별자가 지정되면 반드시 데이터 값이 존재해야 한다 (Null 안 됨)


#   2장 데이터 모델과 성능

##  성능 데이터 모델링

*   절차
    1.  정규화를 정확하게 수행
    2.  데이터베이스 용량산정 수행
    3.  데이터베이스에서 발생하는 트랜잭션의 유형을 파악
    4.  용량과 트랜잭션의 유형에 따라 반정규화를 수행
    5.  이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행

##  정규화
*   갱신 이상 Update Anomalies: 데이터베이스에 연산을 적용하면서 발생하는 이상
    *   삽입 이상
    *   수정 이상
    *   삭제 이상

*   함수적 종속성
    *   함수적 종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다. 
    *   이 때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다.
    *   예: 주민등록번호 -> (이름, 출생지, 주소)

### 정규화 이론
*   1NF
    *   속성의 값은 유일하게 원자값만 허용
    *   다중값 속성을 허용하지 않음
*   2NF
    *   부분 함수 종속성 제거
    *   완전 함수 종속성 만족
*   3NF
    *   이행적 종속성 제거
*   BCNF Boyce-Codd Normal Form

##  반정규화
*   정의
    *   정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
    *   반정규화는 데이터 무결성을 취약하게 만들고, 입력/수정/삭제에 대한 성능을 저하시킨다.

*   필요
    *   데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되는 경우
    *   경로가 너무 멀어 조인으로 인한 성능 저하가 예상되는 경우
    *   칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우

*   절차
    1.  반정규화 대상 조사
    2.  다른 방법유도 검토
        *   Join 대신 View를 사용하여 성능 향상 가능
        *   데이터의 규모 이슈는 클러스터링이나 인덱스 조정을 통해 성능 향상 가능
        *   데이터의 규모 이슈는 파티셔닝(Partitioning) 기법을 통해 성능 향상 가능
        *   로직을 어플리케이션 단에서 구현하거나 데이터 캐싱을 통해 성능 향상 가능
    3.  반정규화 적용
*   종류
    *   칼럼의 반정규화
    *   테이블의 반정규화

*   반정규화를 적용할 때는 기본적으로 데이터 무결성이 깨질 가능성이 많이 있기 때문에 반드시 데이터 무결성을 보장할 수 있는 방법을 고려한 이후에 반정규화를 적용하도록 해야 한다.

*   서버 간에 DB가 정규화되어 있는 경우, 조회할 때마다 서버 간 조인이 발생하므로 이때는 빈번하게 조회되는 속성을 각 DB에 공유하여 서버 간 조인을 막는 이른바 속성 반정규화를 통해 성능을 향상시킬 수 있다.

##  대량 데이터에 따른 성능
*   테이블에 대량의 데이터가 집중되는 경우
    *   대량의 데이터를 처리하기 위해 디스크 I/O량이 증가하는 문제 발생
        *   로우 체이닝: 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
        *   로우 마이그레이션: 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 현상
    *   디스크 I/O를 줄이는 방법
        *   수평 분할(로우 기준)
        *   수직 분할(칼럼 기준)

*   Oracle의 파티셔닝 종류
    *   LIST (예: 지역 위치에 따라 파티셔닝 하는 경우)
    *   RANGE (예: 일자별 데이터를 연/월별로 파티셔닝하는 경우)
    *   HASH 
    *   COMPOSITE
    +   LIST PARTITION은 대용량 데이터를 특정값에 따라 분리 저장할 수는 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.

##  데이터베이스의 구조와 성능
*   슈퍼타입/서브타입


*   PK/FK 칼럼의 순서와 DB 성능
    *   여러 칼럼으로 구성된 복합 PK의 경우, 각 PK들 중'=', '<>'로 조회되는 PK의 순서를 앞에 두어야 한다.
    +   FK 제약과 FK 인덱스는 다르며 쿼리에서 FK 인덱스를 사용하지 않더라도 FK 인덱스는 조인 시 FULL SCAN을 유발하지 않아 성능 향상에 도움이 된다.